BeanFactory vs ApplicationContext

The Spring Framework comes with two IOC containers – BeanFactory and ApplicationContext. The BeanFactory is the most basic version of IOC containers, and the ApplicationContext extends the features of BeanFactory.
BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext. Let's understand it with an example.
ApplicationContext enhances BeanFactory in a more framework-oriented style and provides several features that are suitable for enterprise applications.

For instance, it provides messaging (i18n or internationalization) functionality, event publication functionality, annotation-based dependency injection, and easy integration with Spring AOP features.

spring IOC container.

Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control. 

what is bean lifecycle

Bean life cycle is managed by the spring container. When we run the program then, first of all, the spring container gets started. After that, the container creates the instance of a bean as per the request, and then dependencies are injected. And finally, the bean is destroyed when the spring container is closed. Therefore, if we want to execute some code on the bean instantiation and just after closing the spring container, then we can write that code inside the custom init() method and the destroy() method.

Cloning and types of Cloning in Java
coping

*shallow copy
Abc obj = new ABC();

obj.i = 5;
obj.j = 6;

ABC obj1 = obj ; shallow copy. 
in shallow copy new object will not be created. new refernce is created to same object.

ABC obj1 = new ABC();
obj1.i = obj.i;
obj1.j = obj.j;
this is called deep copy
In deep copy new vairable is created. Problem with deepcopy is if we have 50 variable we need to cpy each and every variable.

object cloning.  using .clone method. 
using clone method we can clone any object. It looks like shallow copy but it is a deepcopy.


Marker Interface. If body is empty then how it manages and why there is need to implement it
Marker Interface. If body is empty then how it manages and why there is need to implement it
maker interface provides permission. eg clonable interface provides permisson to clone objects.
the class which we wants to clone should implemet cloneale interface. which is a marker infterface.
which dont have anything in it. it basically gives permission for cloning.
eg    System.out.println("Hello, World!"); 
        HelloWorld
		obj = new HelloWorld();
        
        if(obj instanceof HelloWorld)
          System.out.println("give permission");
		  
write a program to test a string is palindrome or not.


  String palindrome = "abcba"
  
  for(int i = 0 , j = String.length() -1; i < j ; i++ ,j--)
  {
    if( !(palindrome . charAt(i).equals(palindrome.charAt(j)))){
	   System.out.println("not a palindrom");
	}
  }
   System.out.println("is  a palindrom");

what is the diffence between creating a child object with parent class  refernce and child class refernce

consider a parent class 
public class ParentClass {

	private int value = 10;
	
	public int getValue() {
		return this.value;
	}
	public void setValue(int value) {
		this.value  = value;
	}
}
conisder a child class extending parent class
public class ChildClass extends ParentClass {
  private int value = 1000;
  
  public String getName() {
	return name;
}

public void setName(String name) {
	this.name = name;
}

private String name = "child";

public int getValue() {
	return value;
}

public void setValue(int value) {
	this.value = value;
}
  
}

ParentClass parenntReference  = new ChildClass();
//using  parent refernce we can only access the variables which of child class which are also there in parent class. the feild like "name" is from child class not inherited from //parent  class. so parenntReference cant access field "name" directly. it should access it the shown way.
 
		System.out.println("parenntReference"+parenntReference.getValue()+"parenntReference"+((ChildClass) parenntReference).getName());
		ChildClass childReference  = new ChildClass();
		
//using child class refernce we can access any feild of child class
		System.out.println("childReference"+childReference.getValue()+"child refernce"+childReference.getName());
		
creating a parent object with child refernce  is not at all possible.

  employeeinfo {
    empId 
	first name
	lastname
	department
	project
	adress
	dob
	gender
	
   }
   
   EmplyPosition
   {
    empId
	
	Position
	
	DateOf join
	
	salary
   
   }
   
   SELECT * from EmplyPosition
   WHERE LIMIT N
   
   Write a query to fetch all employees names who also hold the managerial position.
   
   SELECT firstname from employeeinfo   
   WHERE EmplyPosition =  "managerial"
   ON employeeinfo.empID = EmplyPosition.empID.
   
   Write a query to calculate the even and odd records from a table.
   
		  
If key in Hashmap will be Employee object then how the insertion will be done i.e custom hashmap
https://youtu.be/xqhukPTkBsw
public class Employee {

	private String name;
	private int id;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public Employee(String name, int id) {
		this.name = name;
		this.id = id;
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", id=" + id + "]";
	}    
	
	@Override
	public int hashCode() {
		return Objects.hash(id, name);
	}
//	@Override
//	public boolean equals(Object obj) {
//		if (this == obj)
//			return true;
//		if (obj == null)
//			return false;
//		if (getClass() != obj.getClass())
//			return false;
//		Employee other = (Employee) obj;
//		return id == other.id && Objects.equals(name, other.name);
//	}
	public static void main(String []args) {
		System.out.println("Hello ");
		
		HashMap<Employee,String> empMap = new HashMap<>();
		Employee employee1 = new Employee("Alpha", 1);
		Employee employee2 = new Employee("Alpha", 1);
//		here both the objects employee1 and employee2 are equal 
		empMap.put(employee1, "Alpha");
		empMap.put(employee2, "Beta");
		
		System.out.println("both objects are equal"+employee1.equals(employee2) );
		System.out.println("Hashcode of emp1"+employee1.hashCode());
		System.out.println("HashCode of emp2"+employee2.hashCode());
//		output 
//		both objects are equalfalse
//		Hashcode of emp11239731077
//		HashCode of emp2557041912
//      since the hashcodes are differnt and equals method also saying false. these 2 objects may be stored in a differnt bucket.
//		even if they hashmap try to store in same bucket. since the equals method is returning false. it will store both the objects as two separate keys 
//		and duplication will happen.
		
		//if we override only equals method but not the hash code method then we get
//		both objects are equaltrue
//		Hashcode of emp11239731077
//		HashCode of emp2557041912
//		but hash code are  differnt so there is chance of having duplicate keys in differnt buckits. but not in the same bucket.
		
//		if we overide the hashcode but not equals method then output is 
//		both objects are equalfalse
//		Hashcode of emp163358238
//		HashCode of emp263358238
//		so the both objects will have same hashcode . the bucket they are inserted will be same but equals method is fAALSE so it insert the duplicate entry in same bucket	

	}
	
}


How to sort Employee bases on name and then age and then salary
SELECT *
from Employee
Order by name, age, salary DESC

@RestController vs @Controller
@Controller is used to mark classes as Spring MVC Controller.	         @RestController annotation is a special controller used in RESTful Web services, and it’s the combination of @Controller and @ResponseBody annotation.
It is a specialized version of @Component annotation.	                 It is a specialized version of @Controller annotation.
In @Controller, we can return a view in Spring Web MVC.	                 In @RestController, we can not return a view.
@Controller annotation indicates that the class is a “controller” like a web controller.	@RestController annotation indicates that class is a controller where @RequestMapping methods assume @ResponseBody semantics by default.
In @Controller, we need to use @ResponseBody on every handler method.	In @RestController, we don’t need to use @ResponseBody on every handler method.
It was added to Spring 2.5 version.	                                    It was added to Spring 4.0 version.

@ResponseBody annotation
The @ResponseBody annotation tells a controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object.

Why static method is added in Interface in java 8
In the past, if you had an interface Foo and wanted to group interface-related utils or factory methods, you would need to create a separate utils class FooUtils and store everything there.

Those classes would not have anything in common other than the name, and additionally, the utils class would need to be made final and have a private constructor to forbid unwanted usage.

Now, thanks to the interface static methods, you can keep everything in one place without creating any additional classes.

It's also important to not forget all good practices and not throw everything mindlessly to one interface class - as pointed out in this answer

Nth Largest number in array
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("hello");
		int [] arr = new int[10];
		for(int i =0;i<10;i++)
		{
			arr[i]= 10-i;
		}
		ArrayList<Integer>values = new ArrayList<>();
		for(int i =0;i<arr.length;i++) {
			values.add(arr[i]);
		}
		Collections.sort(values);
		System.out.println(values.get(5));
		
	}
	
groupingBy(), publishingBy()

Stream vs Collection
Collection is an in-memory data structure, which holds all the values that the data structure currently has. Every element in the Collection has to be computed before we add it to the Collection. Operations such as searching, sorting, insertion, manipulation, and deletion can be performed on a Collection. It provides many interfaces like (Set, List, Queue, Deque) and Classes like (ArrayList, Vector, LinkedList, PriorityQueue, HashSet).

On the other hand, IStream is an API that is introduced in Java 8 which is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result. The Stream API is used to process collections of objects.

Main features of the Java stream are as follows:

A stream is not a data structure instead it takes input from the Collections, Arrays, or I/O channels.
Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
Each intermediate operation is lazily executed and returns another stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.

1. In which scenario, creating thread using thread is suitable and which scenario creating using runnable is suitable
In the first approach, Our class always extends Thread class. There is no chance of extending any other class. Hence we are missing Inheritance benefits. In the second approach, while implementing Runnable interface we can extends any other class. Hence we are able to use the benefits of Inheritance.
Because of the above reasons, implementing Runnable interface approach is recommended than extending Thread class.
The significant differences between extending Thread class and implementing Runnable interface:
When we extend Thread class, we can’t extend any other class even we require and When we implement Runnable, we can save a space for our class to extend any other class in future or now.
When we extend Thread class, each of our thread creates unique object and associate with it. When we implements Runnable, it shares the same object to multiple threads.

2.how to create Restful web services along with DB operations
it is a topic to cover 
3.what does @springbootaplication mean
*. @SprinBootApplication : it is comination of all the three annotation @EnabaleAutoConfigutation , @ComponentScan,@Configuration

*. @EnabaleAutoConfigutation : this annotation automatically configures the spring application based on jar we added in the pom. xml .
eg: we added dependency of h2 database in pom.xml and we dont configure any beans related to that database manually then springboot auto configration will configure automatically that dependency to us. 

*@componentScan: this annotation is used to scan all the beans so that those will be visible to IOC container. if we want to load specific package to container we will use "basepackage" and mention the package 

*@Cofiguration: we use this annotation for java based configration . where we can define a bean in the @configration class and bean will be created and available.
eg: 

@Configuration
public class cofig{

@Bean
public TeastBean testBean(){
return new TestBean();
  }
} 
by this configration new object of TestBean will be created and can we used in the application

4.List of collection where we have to filter it using stream or foreach and then collect it into map or replace the element

		List<Person>persons = new ArrayList<>();
		Person person1 = new Person("person1", "US");
		Person person2 = new Person("person2", "UK");
		Person person3 = new Person("person3", "Brazil");
		Person person4 = new Person("person4", "US");
		Person person5 = new Person("person5", "Germany");
		Person person6 = new Person("person6", "US");
		Person person7 = new Person("person7", "US");
		Person person8 = new Person("person8", "Germany");
		Person person9 = new Person("person9", "US");
		Person person10 = new Person("person10", "Germany");
		
		persons.add(person1);
		persons.add(person2);
		persons.add(person3);
		persons.add(person4);
		persons.add(person5);
		persons.add(person6);
		persons.add(person7);
		persons.add(person8);
		persons.add(person9);
		persons.add(person10);
		persons = persons.stream().filter( person -> person.getCountry().equalsIgnoreCase("US")).collect(Collectors.toList());
	     for( Person person : persons) {
	    	 System.out.println(person.toString());
	     }

5 .how do we create singleton class .what is design pattern and why it is implemented
n object-oriented programming, a singleton class is a class that can have only one object (an instance of the class) at a time. After the first time, if we try to instantiate the Singleton class, the new variable also points to the first instance created. So whatever modifications we do to any variable inside the class through any instance, affects the variable of the single instance created and is visible if we access that variable through any variable of that class type defined. 
Remember the key points while defining class as a singleton class that is while designing a singleton class: 

Make a constructor private.
Write a static method that has the return type object of this singleton class. Here, the concept of Lazy initialization is used to write this static method.
Purpose of Singleton Class
The primary purpose of a Single class is to restrict the limit of the number of object creation to only one. This often ensures that there is access control to resources, for example, socket or database connection.

The memory space wastage does not occur with the use of the singleton class because it restricts the instance creation. As the object creation will take place only once instead of creating it each time a new request is made.

We can use this single object repeatedly as per the requirements. This is the reason why the multi-threaded and database applications mostly make use of the Singleton pattern in Java for caching, logging, thread pooling, configuration settings, and much more.

For example, there is a license with us, and we have only one database connection or suppose if our JDBC driver does not allow us to do multithreading, then Singleton class comes into the picture and makes sure that at a time, only a single connection or a single thread can access the connection.
6.what is agaile

7. From inn sql, constraints in sql, index ,second highest and third highest salary , view .
SQL Constraints
SQL constraints are used to specify rules for the data in a table.

Constraints are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the table. If there is any violation between the constraint and the data action, the action is aborted.

Constraints can be column level or table level. Column level constraints apply to a column, and table level constraints apply to the whole table.

The following constraints are commonly used in SQL:

NOT NULL - Ensures that a column cannot have a NULL value\
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255) NOT NULL,
    Age int
);
ALTER TABLE Persons
MODIFY Age int NOT NULL;

UNIQUE - Ensures that all values in a column are different
The UNIQUE constraint ensures that all values in a column are different.

Both the UNIQUE and PRIMARY KEY constraints provide a guarantee for uniqueness for a column or set of columns.

A PRIMARY KEY constraint automatically has a UNIQUE constraint.

However, you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);
https://www.w3schools.com/sql/sql_unique.asp  more on unique


PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
The PRIMARY KEY constraint uniquely identifies each record in a table.
Primary keys must contain UNIQUE values, and cannot contain NULL values.
A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields).
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);

FOREIGN KEY - Prevents actions that would destroy links between tables
The FOREIGN KEY constraint is used to prevent actions that would destroy links between tables.
A FOREIGN KEY is a field (or collection of fields) in one table, that refers to the PRIMARY KEY in another table.
The table with the foreign key is called the child table, and the table with the primary key is called the referenced or parent table.
CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
);

CHECK - Ensures that the values in a column satisfies a specific condition
The CHECK constraint is used to limit the value range that can be placed in a column.
If you define a CHECK constraint on a column it will allow only certain values for this column.
If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CHECK (Age>=18)
);

DEFAULT - Sets a default value for a column if no value is specified
The DEFAULT constraint is used to set a default value for a column.
The default value will be added to all new records, if no other value is specified.
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255) DEFAULT 'Sandnes'
);

CREATE INDEX - Used to create and retrieve data from the database very quickly
The CREATE INDEX statement is used to create indexes in tables.
Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.
CREATE INDEX idx_lastname
ON Persons (LastName);

CREATE INDEX idx_pname
ON Persons (LastName, FirstName);

from is a keyword in sql to say from which tabel we need to fetch data

Create table Employees
(
 ID int primary key identity,
 FirstName nvarchar(50),
 LastName nvarchar(50),
 Gender nvarchar(50),
 Salary int
)
GO

Insert into Employees values ('Ben', 'Hoskins', 'Male', 70000)
Insert into Employees values ('Mark', 'Hastings', 'Male', 60000)
Insert into Employees values ('Steve', 'Pound', 'Male', 45000)
Insert into Employees values ('Ben', 'Hoskins', 'Male', 70000)
Insert into Employees values ('Philip', 'Hastings', 'Male', 45000)
Insert into Employees values ('Mary', 'Lambeth', 'Female', 30000)
Insert into Employees values ('Valarie', 'Vikings', 'Female', 35000)
Insert into Employees values ('John', 'Stanmore', 'Male', 80000)
GO

To find the highest salary it is straight forward. We can simply use the Max() function as shown below.
Select Max(Salary) from Employees

To get the second highest salary use a sub query along with Max() function as shown below.
Select Max(Salary) from Employees where Salary [ (Select Max(Salary) from Employees)

To find nth highest salary using Sub-Query
SELECT TOP 1 SALARY
FROM (
      SELECT DISTINCT TOP N SALARY
      FROM EMPLOYEES
      ORDER BY SALARY DESC
      ) RESULT
ORDER BY SALARY

To find nth highest salary using CTE
WITH RESULT AS
(
    SELECT SALARY,
           DENSE_RANK() OVER (ORDER BY SALARY DESC) AS DENSERANK
    FROM EMPLOYEES
)
SELECT TOP 1 SALARY
FROM RESULT
WHERE DENSERANK = N

To find 2nd highest salary we can use any of the above queries. Simple replace N with 2. 

Similarly, to find 3rd highest salary, simple replace N with 3. 

Please Note: On many of the websites, you may have seen that, the following query can be used to get the nth highest salary. The below query will only work if there are no duplicates.
WITH RESULT AS
(
    SELECT SALARY,
           ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS ROWNUMBER
    FROM EMPLOYEES
)
SELECT SALARY
FROM RESULT
WHERE ROWNUMBER = 3

8. bean life cycle .'
The lifecycle of any object means when & how it is born, how it behaves throughout its life, and when & how it dies. Similarly, the bean life cycle refers to when & how the bean is instantiated, what action it performs until it lives, and when & how it is destroyed. In this article, we will discuss the life cycle of the bean. 

Bean life cycle is managed by the spring container. When we run the program then, first of all, the spring container gets started. After that, the container creates the instance of a bean as per the request, and then dependencies are injected. And finally, the bean is destroyed when the spring container is closed. Therefore, if we want to execute some code on the bean instantiation and just after closing the spring container, then we can write that code inside the custom init() method and the destroy() method.


9. Dev tools in microservices architecture.
Top 9 Microservice Tools
Tools for microservice development mostly divided into the following category, which plays an essential role in microservice development by increasing the developers’ productivity.

Programming Language
Architectural Frameworks
Build and assembly
Message queuing
Containerization
Cloud deployment
Application monitoring
API Testing and management
Team building

80 . I have any employee class which is having employeename , employeeId, designation. a simple POJO class. 
I want to use employee class object as key for the hashmap.

81. tell me about concurrent hashmap.
10. how hashmap, hashset and hashtabel works internally.
hashset
Differences between HashMap and HashTable in Java

Difficulty Level : Easy
Last Updated : 23 Jan, 2022
HashMap and Hashtable store key and value pairs in a hash table. When using a Hashtable or HashMap, we specify an object that is used as a key and the value that you want to be linked to that key. The key is then hashed, and the resulting hash code is used as the index at which the value is stored within the table. Now let us discuss with the help of an example.

Hashmap vs Hashtable 

HashMap is non-synchronized. It is not thread-safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
HashMap is generally preferred over HashTable if thread synchronization is not needed.
Difference Between Hashmap and Hashtable
S. No.	Hashmap	Hashtable
1.	No method is synchronized.	Every method is synchronized.
2.	Multiple threads can operate simultaneously and hence hashmap’s object is not thread-safe.	At a time only one thread is allowed to operate the Hashtable’s object. Hence it is thread-safe.
3.	Threads are not required to wait and hence relatively performance is high.	It increases the waiting time of the thread and hence performance is low.
4.	Null is allowed for both key and value.	Null is not allowed for both key and value. Otherwise, we will get a null pointer exception.
5.	It is introduced in the 1.2 version.	It is introduced in the 1.0 version.
6. 	It is non-legacy.	It is a legacy.
Now you must be wondering why HashTable doesn’t allow null and HashMap do? 

The answer is simple. In order to successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.

11.hashmap vs hashtabel
Differences between HashMap and HashTable in Java

Difficulty Level : Easy
Last Updated : 23 Jan, 2022
HashMap and Hashtable store key and value pairs in a hash table. When using a Hashtable or HashMap, we specify an object that is used as a key and the value that you want to be linked to that key. The key is then hashed, and the resulting hash code is used as the index at which the value is stored within the table. Now let us discuss with the help of an example.

Hashmap vs Hashtable 

HashMap is non-synchronized. It is not thread-safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
HashMap is generally preferred over HashTable if thread synchronization is not needed.
Difference Between Hashmap and Hashtable
S. No.	Hashmap	Hashtable
	No method is synchronized.	Every method is synchronized.
	Multiple threads can operate simultaneously and hence hashmap’s object is not thread-safe.	At a time only one thread is allowed to operate the Hashtable’s object. Hence it is thread-safe.
	Threads are not required to wait and hence relatively performance is high.	It increases the waiting time of the thread and hence performance is low.
	Null is allowed for both key and value.	Null is not allowed for both key and value. Otherwise, we will get a null pointer exception.
	It is introduced in the 1.2 version.	It is introduced in the 1.0 version.
 	It is non-legacy.	It is a legacy.
Now you must be wondering why HashTable doesn’t allow null and HashMap do? 

The answer is simple. In order to successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.
Concurrent Hashmap is a class that was introduced in jdk1.5.  Concurrent hash map applies locks only at bucket level called fragment while adding or updating the map. So, a concurrent hash map allows concurrent read and write operations to the map. 

HashTable is a thread-safe legacy class introduced in the Jdk1.1. It is a base implementation of Map interface. It doesn't allow null keys and values. It is synchronized in nature so two different threads can’t access simultaneously. Hashtable does not maintain any order.

Sr. No.
Key
HashTable
ConcurrentHashMap
Basic 
HashTable is a thread-safe legacy class introduced in the Jdk1.1
 ConcurrentHashmap is a class that was introduced in jdk1.5

Locking
It applies lock on the entire collection 
ConcurrentHashMap apply locks only at bucket level called fragment  while adding or updating the map

Performance 
It is slower than  ConcurrentHashMap
It is better than HashTable

Null
It doesn't allow null key and value
It allows null key and value

12. tread , thread ppol..??
Java Thread pool represents a group of worker threads that are waiting for the job and reused many times.
In the case of a thread pool, a group of fixed-size threads is created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, the thread is contained in the thread pool again.
Thread Pool Methods
newFixedThreadPool(int s): The method creates a thread pool of the fixed size s.

newCachedThreadPool(): The method creates a new thread pool that creates the new threads when needed but will still use the previously created thread whenever they are available to use.

newSingleThreadExecutor(): The method creates a new thread.

Advantage of Java Thread Pool
Better performance It saves time because there is no need to create a new thread.

Real time usage
It is used in Servlet and JSP where the container creates a thread pool to process the request.



13. types of annotations in spring
topic to be discussed

14. sleep() vs wait() in thread
sleep() is a method which is used to pause the process for few seconds or the time we want to. But in case of wait() method, thread goes in waiting state and it won’t come back automatically until we call the notify() or notifyAll().

The major difference is that wait() releases the lock or monitor while sleep() doesn’t releases the lock or monitor while waiting. wait() is used for inter-thread communication while sleep() is used to introduce pause on execution, generally.

Thread.sleep() sends the current thread into the “Not Runnable” state for some amount of time. The thread keeps the monitors it has acquired — i.e. if the thread is currently in a synchronized block or method no other thread can enter this block or method. If another thread calls t.interrupt(). it will wake up the sleeping thread.

While sleep() is a static method which means that it always affects the current thread (the one that is executing the sleep method). A common mistake is to call t.sleep() where t is a different thread; even then, it is the current thread that will sleep, not the t thread.

15. Class level lock vs object level lock
Synchronization: 

Synchronization is a modifier that is used for the method and blocks only. With the help of a synchronized modifier, we can restrict a shared resource to be accessed only by one thread. When two or more threads need access to shared resources, there is some loss of data i.e. data inconsistency. The process by which we can achieve data consistency between multiple threads is called Synchronization.

Why do you need Synchronization

Let us assume if you have two threads that are reading and writing to the same ‘resource’. Suppose there is a variable named geek, and you want that at one time only one thread should access the variable(atomic way). But Without the synchronized keyword, your thread 1 may not see the changes thread 2 made to geek, or worse, it may only be half changed that cause the data inconsistency problem. This would not be what you logically expect. The tool needed to prevent these errors is synchronization.

In synchronization, there are two types of locks on threads:  

Object-level lock: Every object in java has a unique lock. Whenever we are using a synchronized keyword, then only the lock concept will come into the picture. If a thread wants to execute then synchronized method on the given object. First, it has to get a lock-in that object. Once the thread got the lock then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. Acquiring and release lock internally is taken care of by JVM and the programmer is not responsible for these activities. Let’s have a look at the below program to understand the object level lock:

// Java program to illustrate
// Object lock concept
class Geek implements Runnable {
    public void run() { Lock(); }
    public void Lock()
    {
        System.out.println(
            Thread.currentThread().getName());
        synchronized (this)
        {
            System.out.println(
                "in block "
                + Thread.currentThread().getName());
            System.out.println(
                "in block "
                + Thread.currentThread().getName()
                + " end");
        }
    }
 
    public static void main(String[] args)
    {
        Geek g = new Geek();
        Thread t1 = new Thread(g);
        Thread t2 = new Thread(g);
        Geek g1 = new Geek();
        Thread t3 = new Thread(g1);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();
    }
}
Output
t1
t3
t2
in block t3
in block t1
in block t3 end
in block t1 end
in block t2
in block t2 end
Class level lock: Every class in Java has a unique lock which is nothing but a class level lock. If a thread wants to execute a static synchronized method, then the thread requires a class level lock. Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class. Once method execution completes automatically thread releases the lock. Let’s look at the below program for better understanding:

// Java program to illustrate class level lock
class Geek implements Runnable {
    public void run() { Lock(); }
 
    public void Lock()
    {
        System.out.println(
            Thread.currentThread().getName());
        synchronized (Geek.class)
        {
            System.out.println(
                "in block "
                + Thread.currentThread().getName());
            System.out.println(
                "in block "
                + Thread.currentThread().getName()
                + " end");
        }
    }
 
    public static void main(String[] args)
    {
        Geek g1 = new Geek();
        Thread t1 = new Thread(g1);
        Thread t2 = new Thread(g1);
        Geek g2 = new Geek();
        Thread t3 = new Thread(g2);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();
    }
}
Output
t1
t2
t3
in block t1
in block t1 end
in block t3
in block t3 end
in block t2
in block t2 end

16. JVM architecture.
JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.

JVMs are available for many hardware and software platforms (i.e. JVM is platform dependent).Let's understand the internal architecture of JVM. It contains classloader, memory area, execution engine etc.

JVM Architecture

17. spring immutability


18.  

19. garbage collector - system.gc() ->how finalise() called 

20. list of employees how will i rename idenentical employee from list

21. serializable
The Serializable interface is present in java.io package. It is a marker interface. A Marker Interface does not have any methods and fields. Thus classes implementing it do not have to implement any methods. Classes implement it if they want their instances to be Serialized or Deserialized. Serialization is a mechanism of converting the state of an object into a byte stream. Serialization is done using ObjectOutputStream. Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory. This mechanism is used to persist the object. Deserialization is done using ObjectInputStream. Thus it can be used to make an eligible for saving its state into a file. 

22. transient keyword in java
transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.

transient keyword plays an important role to meet security constraints. There are various real-life examples where we don’t want to save private data in file. Another use of transient keyword is not to serialize the variable whose value can be calculated/derived using other serialized objects or system such as age of a person, current date, etc.
Practically we serialized only those fields which represent a state of instance, after all serialization is all about to save state of an object to a file. It is good habit to use transient keyword with private confidential fields of a class during serialization.


// A sample class that uses transient keyword to
// skip their serialization.
class Test implements Serializable
{
    // Making password transient for security
    private transient String password;
  
    // Making age transient as age is auto-
    // computable from DOB and current date.
    transient int age;
  
    // serialize other fields
    private String username, email;
    Date dob;
  
    // other code
}
transient and static : Since static fields are not part of state of the object, there is no use/impact of using transient keyword with static variables. However there is no compilation error.

transient and final : final variables are directly serialized by their values, so there is no use/impact of declaring final variable as transient. There is no compile-time error though.

23. volatile 
https://www.geeksforgeeks.org/volatile-keyword-in-java/
Using volatile is yet another way (like synchronized, atomic wrapper) of making class thread-safe. Thread-safe means that a method or class instance can be used by multiple threads at the same time without any problem. Consider the below example. 

class SharedObj
{
   // Changes made to sharedVar in one thread
   // may not immediately reflect in other thread
   static int sharedVar = 6;
}
Suppose that two threads are working on SharedObj. If two threads run on different processors each thread may have its own local copy of sharedVariable. If one thread modifies its value the change might not reflect in the original one in the main memory instantly. This depends on the write policy of cache. Now the other thread is not aware of the modified value which leads to data inconsistency.
Note that volatile should not be confused with the static modifier. static variables are class members that are shared among all objects. There is only one copy of them in the main memory. 
volatile vs synchronized: Before we move on let’s take a look at two important features of locks and synchronization. 
Mutual Exclusion: It means that only one thread or process can execute a block of code (critical section) at a time.
Visibility: It means that changes made by one thread to shared data are visible to other threads.
Java’s synchronized keyword guarantees both mutual exclusion and visibility. If we make the blocks of threads that modify the value of the shared variable synchronized only one thread can enter the block and changes made by it will be reflected in the main memory. All other threads trying to enter the block at the same time will be blocked and put to sleep. 

In some cases, we may only desire visibility and not atomicity. The use of synchronized in such a situation is overkill and may cause scalability problems. Here volatile comes to the rescue. Volatile variables have the visibility features of synchronized but not the atomicity features. The values of the volatile variable will never be cached and all writes and reads will be done to and from the main memory. However, the use of volatile is limited to a very restricted set of cases as most of the times atomicity is desired. For example, a simple increment statement such as x = x + 1; or x++ seems to be a single operation but is really a compound read-modify-write sequence of operations that must execute atomically. 

24. implementation classes of list(I) & set(I)
In Java, both the List and the Set are available in the Collection framework. In order to store the collection of objects as a single unit, Set and List interface are used. Apart from these similarities, both the interfaces have so many differences too, which are as follows:

S.No	List	                                                                     Set
1.	The list implementation allows us to add the same or duplicate elements.	The set implementation doesn't allow us to add the same or duplicate elements.
2.	The insertion order is maintained by the List.	                            It doesn't maintain the insertion order of elements.
3.	List allows us to add any number of null values.	                        Set allows us to add at least one null value in it.
4.	The List implementation classes are LinkedList and ArrayList.	               The Set implementation classes are TreeSet, HashSet and LinkedHashSet.
5.	We can get the element of a specified index from the list using the get() method.	We cannot find the element from the Set based on the index because it doesn't provide any get method().
6.	It is used when we want to frequently access the elements by using the index.	It is used when we want to design a collection of distinct elements.
7.	The method of List interface listiterator() is used to iterate the List elements.	The iterator is used when we need to iterate the Set elements.

25.list  of annotations in springboot.

26. what is mock
Mockito is a java based mocking framework, used in conjunction with other testing frameworks such as JUnit and TestNG.

It internally uses Java Reflection API and allows to create objects of a service. A mock object returns a dummy data and avoids external dependencies. It simplifies the development of tests by mocking external dependencies and apply the mocks into the code under test.

27 string buffer vs String builder
Java provides three classes to represent a sequence of characters: String, StringBuffer, and StringBuilder. The String class is an immutable class whereas StringBuffer and StringBuilder classes are mutable. There are many differences between StringBuffer and StringBuilder. The StringBuilder class is introduced since JDK 1.5.

A list of differences between StringBuffer and StringBuilder is given below:

Difference between StringBuffer and StringBuilder
No.	StringBuffer	StringBuilder
1)	StringBuffer is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.	StringBuilder is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
2)	StringBuffer is less efficient than StringBuilder.	StringBuilder is more efficient than StringBuffer.
3)	StringBuffer was introduced in Java 1.0	StringBuilder was introduced in Java 1.5

28 when to arraylist & linked List.
ArrayList provides constant time for search operation, so it is better to use ArrayList if searching is more frequent operation than add and remove operation. The LinkedList provides constant time for add and remove operations. So it is better to use LinkedList for manipulation.

ArrayList has O(1) time complexity to access elements via the get and set methods.

LinkedList has O(n/2) time complexity to access the elements.

LinkedLinked class implements Deque interface also, so you can get the functionality of double ended queue in LinkedList. The ArrayList class doesn't implement Deque interface.

In sort, ArrayList is better to access data wherease LinkedList is better to manipulate data. Both classes implements List interface.

29. view, trigger in sql 
 A trigger is a stored procedure in database which automatically invokes whenever a special event in the database occurs. For example, a trigger can be invoked when a row is inserted into a specified table or when certain table columns are being updated.

Syntax:

create trigger [trigger_name] 
[before | after]  
{insert | update | delete}  
on [table_name]  
[for each row]  
[trigger_body] 

BEFORE and AFTER of Trigger:
BEFORE triggers run the trigger action before the triggering statement is run.
AFTER triggers run the trigger action after the triggering statement is run.

30. what is maven and what are differnt types of maven repository..??
A maven repository is a directory of packaged JAR file with pom.xml file. Maven searches for dependencies in the repositories. There are 3 types of maven repository:

Local Repository
in your file system m2 folder
Central Repository
Maven central repository is located on the web. It has been created by the apache maven community itself.

The path of central repository is: http://repo1.maven.org/maven2/.
Remote Repository
Maven remote repository is located on the web. Most of libraries can be missing from the central repository such as JBoss library etc, so we need to define remote repository in pom.xml file.

Let's see the code to add the jUnit library in pom.xml file.

31 how to objects interact with each other
Typically, Java programs that you write will create many different objects from templates known as classes. These objects interact with one another by sending each other messages. The result of a message is a method invocation which performs some action or modifies the state of the receiving object.

32 new features of java8
Lambda expressions,
Method references,
Functional interfaces,
Stream API,
Default methods,
Base64 Encode Decode,
Static methods in interface,
Optional class,
Collectors class,
ForEach() method,
Nashorn JavaScript Engine,
Parallel Array Sorting,
Type and Repating Annotations,
IO Enhancements,
Concurrency Enhancements,
JDBC Enhancements etc.


33 syntax of writing syncroinsed method and block 
Synchronized block can be used to perform synchronization on any specific resource of the method.
Suppose we have 50 lines of code in our method, but we want to synchronize only 5 lines, in such cases, we can use synchronized block.
If we put all the codes of the method in the synchronized block, it will work same as the synchronized method.
Synchronized block is used to lock an object for any shared resource.
Scope of synchronized block is smaller than the method.
A Java synchronized block doesn't allow more than one JVM, to provide access control to a shared resource.
The system performance may degrade because of the slower working of synchronized keyword.
Java synchronized block is more efficient than Java synchronized method.
// A Sender class  
class Sender   
{   
  public void SenderMsg(String msg)  
  {   
    System.out.println("\nSending a Message: "  + msg);  
    try  
    {   
      Thread.sleep(800);   
    }   
    catch (Exception e)   
    {   
      System.out.println("Thread interrupted.");   
    }   
    System.out.println("\n" +msg+ "Sent");  
  }  
}   
// A Sender class for sending a message using Threads   
class SenderWThreads extends Thread   
{   
  private String msg;   
  Sender sd;   
  
  // Receiver method to receive a message object and a message to be sent   
  SenderWThreads(String m, Sender obj)  
  {   
    msg = m;  
    sd = obj;   
  }   
  
  public void run()   
  {   
    // Checks that only one thread sends a message at a time.   
    synchronized(sd)   
    {   
      // synchronizing the sender object   
      sd.SenderMsg(msg);  
    }   
  }   
}   
// Driver Code   
public class ShynchronizedMultithreading  
{   
  public static void main(String args[])   
  {   
    Sender sender = new Sender();   
    SenderWThreads sender1 = new SenderWThreads( "Hola " , sender);  
SenderWThreads sender2 =  new SenderWThreads( "Welcome to Javatpoint website ", sender);  
  
    // Start two threads of SenderWThreads type   
    sender1.start();   
    sender2.start();   
  
    // wait for threads to end   
    try  
    {   
      sender1.join();   
      sender2.join();   
    }   
    catch(Exception e)   
    {   
      System.out.println("Interrupted");   
    }   
  }   
}  
34 if private main method is written then what will happen ? will JVM access main()..?? if error then complie time error or runtime error
Yes, we can declare the main method as private in Java.

It compiles successfully without any errors but at the runtime, it says that the main method is not public.
The above code is working successfully at compile time but it will throw an error at the runtime.

35. abstract vs interface
Abstract class and interface both are used to achieve abstraction where we can declare the abstract methods. Abstract class and interface both can't be instantiated.

But there are many differences between abstract class and interface that are given below.

Abstract class	                                                  Interface
1) Abstract class can have abstract and non-abstract methods.	Interface can have only abstract methods. Since Java 8, it can have default and static methods also.
2) Abstract class doesn't support multiple inheritance.	Interface supports multiple inheritance.
3) Abstract class can have final, non-final, static and non-static variables.	Interface has only static and final variables.
4) Abstract class can provide the implementation of interface.	Interface can't provide the implementation of abstract class.
5) The abstract keyword is used to declare abstract class.	The interface keyword is used to declare interface.
6) An abstract class can extend another Java class and implement multiple Java interfaces.	An interface can extend another Java interface only.
7) An abstract class can be extended using keyword "extends".	An interface can be implemented using keyword "implements".
8) A Java abstract class can have class members like private, protected, etc.	Members of a Java interface are public by default.
9)Example:
public abstract class Shape{
public abstract void draw();
}	Example:
public interface Drawable{
void draw();
}
Simply, abstract class achieves partial abstraction (0 to 100%) whereas interface achieves fully abstraction (100%).
 
 
36. advantage of collection over array.
Arrays are fixed in size that is once we create an array we can not increased or decreased based on our requirement.	Collection are growable in nature that is based on our requirement. We can increase or decrease of size.
With respect to memory Arrays are not recommended to use.	With respect to memory collection are recommended to use.
With respect to performance Arrays are recommended to use.	With respect to performance collection are not recommended to use.
Arrays can hold only homogeneous data types elements.	Collection can hold both homogeneous and and heterogeneous elements.
There is no underlying data structure for arrays and hence ready made  method support is not available.	Every collection class is implemented based on some standard data structure and hence for every requirement ready made method support is available being a performance. we can use these method directly and We are not responsible to implement these methods.
Arrays can hold both object and primitive.	Collection can hold only object types but not primitive datatypes such as int, long, short, etc. 
37. Is JVM interpereter platform dependent.
When we say Java is Platform independent, we are referring to the language and not the interpreters.

The interpreters need to be system dependent. They need to speak two languages. They need understand the Java bytecode and translate it to a language or instructions that the machine understands. Hence, the name interpreters.
39. what are interpreter and jit complier in java
The Just-In-Time (JIT) compiler is a an essential part of the JRE i.e. Java Runtime Environment, that is responsible for performance optimization of java based applications at run time. Compiler is one of the key aspects in deciding performance of an application for both parties i.e. the end user and the application developer.

Java JIT Compiler : General Overview

Bytecode is one of the most important features of java that aids in cross-platform execution. Way of converting bytecode to native machine language for execution has a huge impact on the speed of it. These Bytecode have to be interpreted or compiled to proper machine instructions depending on the instruction set architecture. Moreover these can be directly executed if the instruction architecture is bytecode based. Interpreting the bytecode affects the speed of execution.
In order to improve performance, JIT compilers interact with the Java Virtual Machine (JVM) at run time and compile suitable bytecode sequences into native machine code. While using a JIT compiler, the hardware is able to execute the native code, as compared to having the JVM interpret the same sequence of bytecode repeatedly and incurring an overhead for the translation process. This subsequently leads to performance gains in the execution speed, unless the compiled methods are executed less frequently.
The JIT compiler is able to perform certain simple optimizations while compiling a series of bytecode to native machine language. Some of these optimizations performed by JIT compilers are data-analysis, reduction of memory accesses by register allocation, translation from stack operations to register operations, elimination of common sub-expressions etc. The greater is the degree of optimization done, the more time a JIT compiler spends in the execution stage. Therefore it cannot afford to do all the optimizations that a static compiler is capable of, because of the extra overhead added to the execution time and moreover it’s view of the program is also restricted.
40. can we store float value to double.
yes we ca store. there is no data loss if we store float in double.

42. how to get value form application.properties file and also from custom propeties file.
using @Value annotation 
eg: @Value("${userBucket.path}")
private String userBucketPath;

43. how to calicualte age if we give dob.
public static int calculateAge(LocalDate dob)   
{  
//creating an instance of the LocalDate class and invoking the now() method      
//now() method obtains the current date from the system clock in the default time zone      
LocalDate curDate = LocalDate.now();  
//calculates the amount of time between two dates and returns the years  
if ((dob != null) && (curDate != null))   
{  
return Period.between(dob, curDate).getYears();  
}  
else  
{  
return 0;  
}  
} 

44. how "this " is used in lamda expression.??
The "this" and "super" references within a lambda expression are the same as in the enclosing context. Since the lambda expression doesn't define a new scope, "this" keyword within a lambda expression signifies "this" parameter of a method where the lambda expression is residing.

In the below example, this.toString() calls the toString() method of the LambdaTest object but not the toString() method of the Operate instance.
@FunctionalInterface
interface Operate {
   int func(int num1, int num2);
   public String toString();
}
public class LambdaTest {
   public static void main(String[] args) {
      LambdaTest test = new LambdaTest();
      test.getResult();
   }
   public void getResult() {
      Operate op = (num1, num2) -> { // lambda expression
         System.out.println("This hashcode: " + this.hashCode());
         System.out.println("Calling toString(): "+ this.toString());
         return num1 + num2;
      };
      System.out.println("Result is: "+ funcInt.func(10, 7));
   }
   @Override
   public String toString() {
      System.out.println("Super hashcode: " + super.hashCode());
      return Integer.toString(super.hashCode());
   }
}


45. SOA vs monolitic vs microserives
A monolithic architecture is comfortable for small teams to work with, which is why many startups choose this approach when building an app. Сomponents of monolithic software are interconnected and interdependent, which helps the software be self-contained. This architecture is a traditional solution for building applications, but some developers find it outdated. However, we believe that a monolithic architecture is a perfect solution in some circumstancesA monolithic architecture is comfortable for small teams to work with, which is why many startups choose this approach when building an app. Сomponents of monolithic software are interconnected and interdependent, which helps the software be self-contained. This architecture is a traditional solution for building applications, but some developers find it outdated. However, we believe that a monolithic architecture is a perfect solution in some circumstances
here are lots of tools you can integrate to facilitate development. In addition, all actions are performed with one directory, which provides for easier deployment. With a monolithic core, developers don’t need to deploy changes or updates separately, as they can do it at once and save lots of time.
A service-oriented architecture (SOA) is a software architecture style that refers to an application composed of discrete and loosely coupled software agents that perform a required function. SOA has two main roles: a service provider and a service consumer. Both of these roles can be played by a software agent. The concept of SOA lies in the following: an application can be designed and built in a way that its modules are integrated seamlessly and can be easily reused.

46. JDBC prepared statements 

47. Spring Boot CLI.
The Spring Boot CLI is a Command Line Interface for Spring Boot. It can be used for a quick start with Spring. It can run Groovy scripts which means that a developer need not write boilerplate code; all that is needed is focus on business logic. Spring Boot CLI is the fastest way to create a Spring-based application.

Features
In this section, we will look at the different features of Spring Boot CL −
It provides an interface to run and test Spring Boot Application from command prompt.
It internally use Spring Boot Starter and Spring Boot AutoConfigurate components in order to resolve all dependencies and executes the application.
It contains Groovy compiler and Grape Dependency Manager.
It supports Groovy Scripts without external Groovy installation.
It adds Spring Boot defaults and resolve all dependencies automatically.

48. cors spring boot
Cross-Origin Resource Sharing (CORS) is a security concept that allows restricting the resources implemented in web browsers. It prevents the JavaScript code producing or consuming the requests against different origin.

For example, your web application is running on 8080 port and by using JavaScript you are trying to consuming RESTful web services from 9090 port. Under such situations, you will face the Cross-Origin Resource Sharing security issue on your web browsers.

Two requirements are needed to handle this issue −

RESTful web services should support the Cross-Origin Resource Sharing.

RESTful web service application should allow accessing the API(s) from the 8080 port.

In this chapter, we are going to learn in detail about How to Enable Cross-Origin Requests for a RESTful Web Service application.

Enable CORS in Controller Method
We need to set the origins for RESTful web service by using @CrossOrigin annotation for the controller method. This @CrossOrigin annotation supports specific REST API, and not for the entire application.



50. default method in java
Before Java 8, interfaces could have only abstract methods. The implementation of these methods has to be provided in a separate class. So, if a new method is to be added in an interface, then its implementation code has to be provided in the class implementing the same interface. To overcome this issue, Java 8 has introduced the concept of default methods which allow the interfaces to have methods with implementation without affecting the classes that implement the interface.


// A simple program to Test Interface default
// methods in java
interface TestInterface
{
    // abstract method
    public void square(int a);
  
    // default method
    default void show()
    {
      System.out.println("Default Method Executed");
    }
}
  
class TestClass implements TestInterface
{
    // implementation of square abstract method
    public void square(int a)
    {
        System.out.println(a*a);
    }
  
    public static void main(String args[])
    {
        TestClass d = new TestClass();
        d.square(4);
  
        // default method executed
        d.show();
    }
}
Output:

 16
 Default Method Executed
51. how do we design a project based on microservices

52. singleton scope VS application scope
https://www.baeldung.com/spring-bean-scopes

this link contains all scopes 

The application scope creates the bean instance for the lifecycle of a ServletContext.
This is similar to the singleton scope, but there is a very important difference with regards to the scope of the bean.
When beans are application scoped, the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton scoped beans are scoped to a single application context only.

When we define a bean with the singleton scope, the container creates a single instance of that bean; all requests for that bean name will return the same object, which is cached. Any modifications to the object will be reflected in all references to the bean. This scope is the default value if no other scope is specified.

53. NOsuchBeanFoundException & how to handel it. how to handel such exception using annotations 
 Spring org.springframework.beans.factory.NoSuchBeanDefinitionException.
This is a common exception thrown by the BeanFactory when trying to resolve a bean that simply isn't defined in the Spring Context.
We'll illustrate the possible causes for this problem and the available solutions.
And of course, exceptions happen when we least expect them, so have a look at the full list of exceptions and solutions in Spring.
https://www.baeldung.com/spring-nosuchbeandefinitionexception

54. @pathVariable and @requestbody
will get all in annotations 

55. how to switch to another internal / external server in springboot 
o far, in previous examples we used to deploy and run the applications using embedded tomcat server provided by the spring boot. Generally in the real-time projects we wont use inbuilt servers provided by the frameworks because of many reasons like security, maintenance and control. So in this article I will show you how can we deploy the spring boot applications on external servers (in this tutorial I am going to consider the external server as Tomcat).

Just do these changes to your spring boot application which you want to deploy it on to external tomcat server.

pom.xml, add dependency and packaging to war
Extend your main class with SpringBootServletInitializer and override its configure method
Generate WAR and deploy into the external server
If want you can change the context path also in the application.properties. (Optional)

56. what is transaction
Transactions group a set of tasks into a single execution unit. Each transaction begins with a specific task and ends when all the tasks in the group successfully complete. If any of the tasks fail, the transaction fails. Therefore, a transaction has only two results: success or failure. 
Incomplete steps result in the failure of the transaction. A database transaction, by definition, must be atomic, consistent, isolated and durable. These are popularly known as 
ACID properties. 
How to implement Transactions using SQL?
Following commands are used to control transactions. It is important to note that these statements cannot be used while creating tables and are only used with the DML Commands such as – INSERT, UPDATE and DELETE. 
1. BEGIN TRANSACTION: It indicates the start point of an explicit or local transaction. 
Syntax:
BEGIN TRANSACTION transaction_name ;
2. SET TRANSACTION: Places a name on a transaction. 

Syntax: 
SET TRANSACTION [ READ WRITE | READ ONLY ];
3. COMMIT: If everything is in order with all statements within a single transaction, all changes are recorded together in the database is called committed. The COMMIT command saves all the transactions to the database since the last COMMIT or ROLLBACK command. 
Syntax: 
 
COMMIT;

57. how to build only few java classes out of  mmultiple java classes present..??
no answer
58. what is fault tolerance in microservices
https://openliberty.io/docs/22.0.0.2/fault-tolerance.html#:~:text=Microservice%2Dbased%20applications%20are%20resilient,strategies%20to%20handle%20common%20errors.
59. what is circuit breaker.
https://openliberty.io/docs/22.0.0.2/fault-tolerance.html#:~:text=Microservice%2Dbased%20applications%20are%20resilient,strategies%20to%20handle%20common%20errors.
60. 3rd highest salry using sql query
  SELECT * ((SELECT *from Employee
ordery by salary DESC TOP 6)AS T)
ORDERBY T.salary ACSC top1
6th highest
mysql> select * from ((select * from Employee 
       ORDER BY `sal` DESC limit 6 ) AS T) 
       ORDER BY T.`sal` ASC limit 1;
Alternate use of Limit:
select * from Employee ORDER BY `sal` ASC limit 5,1; // will return 6th highest 


61. how to restrict some classes from getting auto configured.
Add below similar configuration to your application.yml file,

---
spring:
  profiles: test
  autoconfigure.exclude: org.springframework.boot.autoconfigure.session.SessionAutoConfiguration

62. 403, 501, 404 http status codes.??

HTTP Error 400 - Bad Request
HTTP Error 401 - Unauthorized
HTTP status 403 - Forbidden
HTTP status 404 - Not Found
6/16/22, 11:46 PM What do the HTTP status codes, such as 403, 404, 500, mean? - FAQ | easyname
https://www.easyname.com/en/support/hosting/158-what-do-the-http-status-codes-such-as-403-404-500-mean 2/4
This error message is shown when a site or folder on a server are requested but cannot be found at the
given URL. Please check your input.
Please note that this error can also appear if there is no start file (index.php or index.html).
This error often occurs with the application firewall (mod_security). To protect against attacks on web applications, incoming and outgoing data traffic is checked for rule violations. If an action violates one of
these rules, the corresponding IP address is temporarily blocked and the user receives the status message
"406 - Not Acceptable".
The IP address is automatically unblocked after some time and access to the web application is then possible again. The time period depends on the severity of the violation.
Another possibility to make it accessible again is to deactivate the application firewall. It can be deactivated either for the entire web hosting or only for individual subdomains.
For the entire web hosting: Go to the menu item [Web Hosting] then to [Web Server Settings]. In the lefthand panel General, switch off "Mod Security" and click on the "Save" button.
This option causes new subdomains to be created without protection by the application firewall. For already existing subdomains, the protection must be removed manually.
For individual subdomains: Go to the menu item [Web Hosting] then [Subdomains]. Click on the blue
pen symbol (Edit) next to the corresponding subdomain. Then click on the link Advanced Options. A
menu will open in which you will see a tick next to "Activate application firewall". Click on the tick to deactivate the application firewall. Save your settings by clicking on the "Save" button.
Attention!
Disabling the Application Firewall will make your web application or website more vulnerable to attackers. It is therefore not recommended to disable it.
The server took longer than it's allocated timeout window. In this case the server terminates the
connection.
The HTTP 429 Too Many Requests response status code indicates the user has sent too many requests in a
given amount of time.
A Retry-After header might be included to this response indicating how long to wait before making a new
request. For example if more than 50 requests are received from the same IP address (cumulative hits)
within the same second, our server will block that IP for the next 10 minutes as a security measure.
HTTP status 406 - Not Acceptable
HTTP Error 408 - Request Timeout
HTTP status 429 - Too Many Requests
6/16/22, 11:46 PM What do the HTTP status codes, such as 403, 404, 500, mean? - FAQ | easyname
https://www.easyname.com/en/support/hosting/158-what-do-the-http-status-codes-such-as-403-404-500-mean 3/4
This is a "catch all" status for unexpected errors. The server side error message is commonly caused by eg.
misconfigured .htaccess files or PHP errors, which you you can check in the file php_error.log on your
Webhost.
You can find the php_error.log file in the /log/ directory - this directory can be found on the same level as
your /html/ directory
This HTTP status code indicates, that under the specified URL there's no content to be displayed.
This means, that the server is currently unavailable or the server is overallocated. You can check the file
php_error.log as described for the status code 500.
Should you not find helpful error messages in the logfile, please try changing the session_cache to the option filesystem, you can do this in the easyname control panel if you navigate to [Web Hosting] → [PHP settings] and click the link "Settings".
Please note that this change will take up to 15 minutes to take effect, so please try waiting 15 minutes before trying to call up your site and refresh it.

63. what is the flow of spring bootaplication flow..??
 Presentation Layer
The presentation layer is the top layer of the spring boot architecture. It consists of Views. i.e., the front-end part of the application. It handles the HTTP requests and performs authentication. It is responsible for converting the JSON field’s parameter to Java Objects and vice-versa. Once it performs the authentication of the request it passes it to the next layer. i.e., the business layer.

 Business Layer
The business layer contains all the business logic. It consists of services classes. It is responsible for validation and authorization.

 Persistence Layer
The persistence layer contains all the database storage logic. It is responsible for converting business objects to the database row and vice-versa.

 Database Layer
The database layer contains all the databases such as MySql, MongoDB, etc. This layer can contain multiple databases. It is responsible for performing the CRUD operations.

The Client makes an HTTP request(GET, PUT, POST, etc.)
The HTTP request is forwarded to the Controller. The controller maps the request. It processes the handles and calls the server logic.
The business logic is performed in the Service layer. The spring boot performs all the logic over the data of the database which is mapped to the spring boot model class through Java Persistence Library(JPA).
The JSP page is returned as Response from the controller.

65. disadvantages and advantages of springboot. can spring boot be used for very large aplication
Lack of control. Spring Boot creates a lot of unused dependencies, resulting in a large deployment file;
The complex and time-consuming process of converting a legacy or an existing Spring project to a Spring Boot application;
Not suitable for large-scale projects. Although it’s great for working with microservices, many developers claim that Spring Boot is not suitable for building monolithic applications.


66.@controller  vs                                                     @RestController 
@Controller is used to mark classes as Spring MVC Controller.	       @RestController annotation is a special controller used in RESTful Web services, and it’s of @Controller and @ResponseBody annotation.
It is a specialized version of @Component annotation.	                It is a specialized version of @Controller annotation.
In @Controller, we can return a view in Spring Web MVC.	                In @RestController, we can not return a view.
@Controller annotation indicates that the class is a “controller” like a web controller.	@RestController annotation indicates that class is a controller where @RequestMapping methods assume @ResponseBody semantics by default.
In @Controller, we need to use @ResponseBody on every handler method.	In @RestController, we don’t need to use @ResponseBody on every handler method.
It was added to Spring 2.5 version.	                                    It was added to Spring 4.0 version.

67. bean factory vs                                                    appplication context
It is a fundamental container that provides the basic functionality for managing beans.	It is an advanced container that extends the BeanFactory that provides all basic functionality and adds some advanced features.
It is suitable to build standalone applications.	It is suitable to build Web applications, integration with AOP modules, ORM and distributed applications.
It supports only Singleton and Prototype bean scopes.	It supports all types of bean scopes such as Singleton, Prototype, Request, Session etc.
It does not support Annotations. In Bean Autowiring, we need to configure the properties in XML file only.	It supports Annotation based configuration in Bean Autowiring.
This interface does not provides messaging (i18n or internationalization) functionality.	ApplicationContext interface extends MessageSource interface, thus it provides messaging (i18n or internationalization) functionality.
BeanFactory does not support Event publication functionality.	Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface.
In BeanFactory, we need to manually register BeanPostProcessors and BeanFactoryPostProcessors.	The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup.
BeanFactory will create a bean object when the getBean() method is called thus making it Lazy initialization.	ApplicationContext loads all the beans and creates objects at the time of startup only thus making it Eager initialization.
BeanFactory interface provides basic features only thus requires less memory. For standalone applications where the basic features are enough and when memory consumption is critical, we can use BeanFactory.	ApplicationContext provides all the basic features and advanced features, including several that are geared towards enterprise applications thus requires more memory.

68. List of dulicate employee name , how to print list of map<Empname,Counter> using java 8.
  List<String>names = new ArrayList<>();
     names.add("sai");
     names.add("swaroop");
     names.add("Alex");
     names.add("charles");
     names.add("volvarine");
     names.add("sai");
     names.add("swaroop");
     names.add("sai");
     names.add("Tony");
     names.add("peter");
     names.add("sai");
     
     
     Map<String,Integer>employees = new HashMap<>();
     names.forEach(name->{
    	 if(employees.containsKey(name)) {
    		Integer i = employees.get(name);
    		employees.put(name, i+1);
    	 }
    	 else
    		 employees.put(name, 1);
     });
     System.out.println(employees);
    

69. @trasient
transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.

transient keyword plays an important role to meet security constraints. There are various real-life examples where we don’t want to save private data in file. Another use of transient keyword is not to serialize the variable whose value can be calculated/derived using other serialized objects or system such as age of a person, current date, etc.
Practically we serialized only those fields which represent a state of instance, after all serialization is all about to save state of an object to a file. It is good habit to use transient keyword with private confidential fields of a class during serialization.
class Test implements Serializable
{
    // Making password transient for security
    private transient String password;
  
    // Making age transient as age is auto-
    // computable from DOB and current date.
    transient int age;
  
    // serialize other fields
    private String username, email;
    Date dob;
  
    // other code
}

70. what should we do if multiple services uses some dependencies in pom.xml
We want to setup a common maven project that’s imported by any other project that needs its dependencies. At a high level to do that we need to:

Create a «parent» maven file (pom.xml) - this is a pom.xml which will sit outside all of the projects that make up our microservices and allow us to tie them together - the goal is to make a common project but the easiest way to do that is to first create a parent pom.
Create a common maven project as one of the child projects.
Import the common dependency from any other dependencies that need it
In a simple example where a simple «sales-service» is being built and depends on some common project, the file structure will need to reflect this. We will have something like this at the end of this guide.

.
├── pom.xml     -- the parent pom
├── common
│   ├── pom.xml  -- shared dependencies go in here
│   ├── src
└── sales-service
    ├── pom.xml   -- will be modified to point to our own custom parent pom 
	https://colin-riddell.github.io/post/sharing-dependencies-between-microservices/
	
71. If we need to configure for downloading of jar from somewhere else then. what do we need to do..??
question not proper.
72. differnce between string and string builder 
A string is a sequence of characters. In java, objects of String are immutable which means a constant and cannot be changed once created. Initialize a String is one of the important pillars required as a pre-requisite with deeper understanding. For now, we will be justifying let us do consider the below code with three concatenation functions with three different types of parameters, String, StringBuffer, and StringBuilder. Let us clear out the understanding between them via a single java program below from which we will be drawing out conclusions from the output generated to figure out differences between String vs StringBuilder vs StringBuffer in Java.
https://www.geeksforgeeks.org/string-vs-stringbuilder-vs-stringbuffer-in-java/

73 what is sprinboot
Spring Boot is a project that is built on the top of the Spring Framework. It provides an easier and faster way to set up, configure, and run both simple and web-based applications.

It is a Spring module that provides the RAD (Rapid Application Development) feature to the Spring Framework. It is used to create a stand-alone Spring-based application that you can just run because it needs minimal Spring configuration.
Spring Boot is an open source, microservice-based Java web framework. The  Spring Boot framework creates a fully production-ready environment that is completely configurable using its prebuilt code within its codebase. The microservice architecture provides developers with a fully enclosed application, including embedded application servers.

76. differnce between arraylist and linked list.
ArrayList	LinkedList
1) ArrayList internally uses a dynamic array to store the elements.	LinkedList internally uses a doubly linked list to store the elements.
2) Manipulation with ArrayList is slow because it internally uses an array. If any element is removed from the array, all the other elements are shifted in memory.	Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory.
3) An ArrayList class can act as a list only because it implements List only.	LinkedList class can act as a list and queue both because it implements List and Deque interfaces.
4) ArrayList is better for storing and accessing data.	LinkedList is better for manipulating data.
5) The memory location for the elements of an ArrayList is contiguous.	The location for the elements of a linked list is not contagious.
6) Generally, when an ArrayList is initialized, a default capacity of 10 is assigned to the ArrayList.	There is no case of default capacity in a LinkedList. In LinkedList, an empty list is created when a LinkedList is initialized.
7) To be precise, an ArrayList is a resizable array.	LinkedList implements the doubly linked list of the list interface.

77. differnce between array and arraylist.
Array is a fixed length data structure whereas ArrayList is a variable length Collection class. We cannot change length of array once created in Java but ArrayList can be changed.

We cannot store primitives in ArrayList, it can only store objects. But array can contain both primitives and objects in Java. Since Java 5, primitives are automatically converted in objects which is known as auto-boxing.

79. will hashmap allow duplication of keys.??
No


82. what are equals and hashcode methods in java. can we use these methods to other OBjects than string.
yes we can use these methods in objects also. equals method checkes both objects contain same value or not.  

83. is equals method is in string class.
checks both strings have same content or not.

84. what are java streams. 
Introduced in Java 8, the Stream API is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result.
The features of Java stream are –

A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.
Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.
Different Operations On Streams-
Intermediate Operations:

map: The map method is used to returns a stream consisting of the results of applying the given function to the elements of this stream.
List number = Arrays.asList(2,3,4,5);
List square = number.stream().map(x->x*x).collect(Collectors.toList());
filter: The filter method is used to select elements as per the Predicate passed as argument.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());
sorted: The sorted method is used to sort the stream.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().sorted().collect(Collectors.toList());
Terminal Operations:

collect: The collect method is used to return the result of the intermediate operations performed on the stream.
List number = Arrays.asList(2,3,4,5,3);
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());
forEach: The forEach method is used to iterate through every element of the stream.
List number = Arrays.asList(2,3,4,5);
number.stream().map(x->x*x).forEach(y->System.out.println(y));
reduce: The reduce method is used to reduce the elements of a stream to a single value.
The reduce method takes a BinaryOperator as a parameter.
List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);


 
87. how will you connect to database from your application.
we will provide connection deatils of data base in the application. properties file

88. what is the role of spring IOC container in depencdency injection.
Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control. 

89. what is dependency injection. 
Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”.

Simply put, this allows for loose coupling of components and moves the responsibility of managing components onto the container.

Let's explore DI with Spring further here.

90. Is depencdency injection done only for POJO classes in springboot
In Spring Boot, we can use Spring Framework to define our beans and their dependency injection. The @ComponentScan annotation is used to find beans and the corresponding injected with @Autowired annotation.

this explains that not all the depencdenices mentioned in the pom.xml will be injected to a class. the classes which are @autowired will be injected.

93. how @component differnnt form @bean annotation.
@Componet is used to mention that this 
1
Auto detection
It is used to explicitly declare a single bean, rather than letting Spring do it automatically. 
If any class is annotated with @Component it will be automatically detect by using classpath scan.
2
Spring Container
Bean can be created even class is outside the spring container
We can’t create bean if class is outside spring container
3
Class/Method  Level Annotation
It is a method level annotation
It is a class level annotation
4
@Configuration
It works only when class is also annotated with @Configuration
It works without
@Configuration annotation
5
Use Case
We should use @bean, if you want specific implementation based on dynamic condition.
We can’t write specific implementation based on dynamic condition

94. JVM and JDK.
JVM
JVM is the abbreviation for Java virtual machine which is basically specification that provides a runtime environment in which Java byte code can be executed i.e it is something which is abstract and its implementation is independent to choose the algorithm and has been provided by Sun and other companies. It is JVM which is responsible for converting Byte code to the machine specific code. It can also run those programs which are written in other languages and compiled to Java bytecode.The JVM performs the mentioned tasks: Loads code, Verifies code, Executes code, Provides runtime environment.

JRE
JRE is Java runtime environment which is the implementation of JVM i.e the specifications which are defined in JVM are implemented and creates corresponding environment for the execution of code.JRE comprises mainly java binaries and other classes to execute the program alike of JVM it physically exists. Along with Java binaries JRE also consist of various technologies of deployment, user interfaces to interact with code executed, some base libraries for different functionalities and language and util based libraries.

JDK
JDK is abbreviation for Java Development Kit which includes all the tools, executable and binaries required to compile, debug and execute a Java Program.JDK is platform dependent i.e there is separate installers for Windows, Mac, and Unix systems.JDK includes both JVM and JRE and is entirely responsible for code execution. It is the version of JDK which represent version of Java.

95. how does the JVM manages memory internally.

96. differnt ways of creating objects in java. 
Using new keyword   GFG obj = new GFG();
Using new instance
  Class cls = Class.forName("GFG");
 
            // Creating object of main class
            // using instance method
            GFG obj = (GFG)cls.newInstance();
 
            // Print and display
            System.out.println(obj.name);
Using clone() method
GFG obj2 = (GFG)obj1.clone();
Using deserialization
 try {
            // Creating object of class in main() method
            GFG d = new GFG("GeeksForGeeks");
 
            FileOutputStream f
                = new FileOutputStream("file.txt");
            ObjectOutputStream oos
                = new ObjectOutputStream(f);
            oos.writeObject(d);
            oos.close();
 
            // Freeing up memory resources
            f.close();
        }
Using newInstance() method of Constructor class
Constructor<GFG> constructor
                = GFG.class.getDeclaredConstructor();
 
            GFG r = constructor.newInstance();
 
            // Custom passing
            r.setName("GeeksForGeeks");
            System.out.println(r.name);

97. what does static keyword do
https://www.geeksforgeeks.org/static-keyword-java/
98. why main method is static 
to run a method we need to create a object of that method. but to create a object first we need to run a method. this is a deadlock. if we make a method as static then no need to create a instance.

99. what are oops concepts. 
Pillar 1: Abstraction

Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.
Data Abstraction may also be defined as the process of identifying only the required characteristics of an object, ignoring the irrelevant details. The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the object.
Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the car speed or applying brakes will stop the car, but he does not know how on pressing the accelerator, the speed is actually increasing. He does not know about the inner mechanism of the car or the implementation of the accelerators, brakes etc. in the car. This is what abstraction is. 
In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.

Pillar 2: Encapsulation

It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield. 

Technically, in encapsulation, the variables or the data in a class is hidden from any other class and can be accessed only through any member function of the class in which they are declared.
In encapsulation, the data in a class is hidden from other classes, which is similar to what data-hiding does. So, the terms “encapsulation” and “data-hiding” are used interchangeably.
Encapsulation can be achieved by declaring all the variables in a class as private and writing public methods in the class to set and get the values of the variables.
Pillar 3: Inheritance 

Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. 

Let us discuss some frequently used important terminologies:

Superclass: The class whose features are inherited is known as superclass (also known as base or parent class).
Subclass: The class that inherits the other class is known as subclass (also known as derived or extended or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.
Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.
Pillar 4: Polymorphism

It refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently. This is done by Java with the help of the signature and declaration of these entities. 
100. with inheritance we will get parent functionaity to child. if we dont want some particular functionality. what should i do. we need to make that field private. if we dont want a class to be extended. what we need to do. we need to make that class as final.


102. keyword final, finally, finalize
The final keyword can be used with class method and variable. A final class cannot be inherited, a final method cannot be overridden and a final variable cannot be reassigned.

The finally keyword is used to create a block of code that follows a try block. A finally block of code always executes, whether or not an exception has occurred. Using a finally block allows you to run any cleanup-type statements that you just wish to execute, despite what happens within the protected code.

The finalize() method is used just before object is destroyed and can be called just prior to object creation.
public class Tester {
   public void finalize() throws Throwable{
      System.out.println("Object garbage collected.");
   }
   public static void main(String[] args) {

      Tester t = new Tester();
      t = null;
      System.gc();
   }
}
103. diamond problem in java. no choice of extending  2 or more classes.
yes in java we cannot extend 2 classes with a calss eg: class A extends B,C is not possible.
we can overcome this with interfaces . we can implement more than 2 interfaces in java.

104. do you know about anonymous array.
An array in Java without any name is known as an anonymous array. It is an array just for creating and using instantly. Using an anonymous array, we can pass an array with user values without the referenced variable.
class Test {
    public static void main(String[] args)
    {
          // anonymous array
          sum(new int[]{ 1, 2, 3 });
    }
   
    public static void sum(int[] a)
    {
        int total = 0;
 
        // using for-each loop
        for (int i : a)
            total = total + i;
         
        System.out.println("The sum is: " + total);
    }
}
105. In java how to create custom exceptions
Now, let’s see how to create a custom exception in action. Here are the steps:
Create a new class whose name should end with Exception like ClassNameException. This is a convention to differentiate an exception class from regular ones.
Make the class extends one of the exceptions which are subtypes of the java.lang.Exception class. Generally, a custom exception class always extends directly from the Exception class.
Create a constructor with a String parameter which is the detail message of the exception. In this constructor, simply call the super constructor and pass the message.
That’s it. The following is a custom exception class which is created by following the above steps:

public class StudentNotFoundException extends Exception {
 
    public StudentNotFoundException(String message) {
        super(message);
    }
}

public class StudentManager {
 
    public Student find(String studentID) throws StudentNotFoundException {
        if (studentID.equals("123456")) {
            return new Student();
        } else {
            throw new StudentNotFoundException(
                "Could not find student with ID " + studentID);
        }
    }
}
public class StudentTest {
    public static void main(String[] args) {
        StudentManager manager = new StudentManager();
 
        try {
 
            Student student = manager.find("0000001");
 
        } catch (StudentNotFoundException ex) {
            System.err.print(ex);
        }
    }
}
106. typecasting in java.
Convert a value from one data type to another data type is known as type casting.
Converting a lower data type into a higher one is called widening type casting. It is also known as implicit conversion or casting down. It is done automatically. It is safe because there is no chance to lose data. It takes place when:

Both data types must be compatible with each other.
The target type must be larger than the source type.

byte -> short -> char -> int -> long -> float -> double  

Narrowing Type Casting
Converting a higher data type into a lower one is called narrowing type casting. It is also known as explicit conversion or casting up. It is done manually by the programmer. If we do not perform casting then the compiler reports a compile-time error.

double -> float -> long -> int -> char -> short -> byte  
107. what is threading. explain about threading.

108. zagged array in java
A jagged array is an array of arrays such that member arrays can be of different sizes, i.e., we can create a 2-D array but with a variable number of columns in each row. These types of arrays are also known as Jagged arrays. 
syntax int arr_name[][] = new int[][]  {
                                  new int[] {10, 20, 30 ,40},
                                  new int[] {50, 60, 70, 80, 90, 100},
                                  new int[] {110, 120}
                                      };
                                      
                              OR                                     
                                                         
                    int[][] arr_name = {
                          new int[] {10, 20, 30 ,40},
                          new int[] {50, 60, 70, 80, 90, 100},
                          new int[] {110, 120}
                              };
109. can you describe about sentence "write once and run any where".
the code what we write in java can run any where which contains a JVM.

110. types of constructors in java. 
If there is any one parametrized Constructor present in a class, Default Constructor will not be added at Compile time. So if your program has any parameterised constructor containing parameters and no default constructor is specified then you will not be able to create object of that class using Default constructor. we need to explicitly define a default constructor also.

112. pulic class Myclass{
static final int counter;// this will throw error
final int rollNo;
public void test(){
system.out.println(rollNO);
}}
counter is final and 
rollNo is also final. so it will throw error.
If you don't initialize or forget to initialize a blank static final variable then the compiler will complain about it by throwing a compile-time error


113. Immutability in JAVA.
Immutable class in java means that once an object is created, we cannot change its content. In Java, all the wrapper classes (like Integer, Boolean, Byte, Short) and String class is immutable.
114. how to make a immutable class in java
We can create our own immutable class as well. Prior to going ahead do go through characteristics of immutability in order to have a good understanding while implementing the same. Following are the requirements: 

The class must be declared as final so that child classes can’t be created.
Data members in the class must be declared private so that direct access is not allowed.
Data members in the class must be declared as final so that we can’t change the value of it after object creation.
A parameterized constructor should initialize all the fields performing a deep copy so that data members can’t be modified with an object reference.
Deep Copy of objects should be performed in the getter methods to return a copy rather than returning the actual object reference)
final class Student {
 
    // Member attributes of final class
    private final String name;
    private final int regNo;
    private final Map<String, String> metadata;
 
    // Constructor of immutable class
    // Parameterized constructor
    public Student(String name, int regNo,
                   Map<String, String> metadata)
    {
 
        // This keyword refers to current instance itself
        this.name = name;
        this.regNo = regNo;
 
        // Creating Map object with reference to HashMap
        // Declaring object of string type
        Map<String, String> tempMap = new HashMap<>();
 
        // Iterating using for-each loop
        for (Map.Entry<String, String> entry :
             metadata.entrySet()) {
            tempMap.put(entry.getKey(), entry.getValue());
        }
 
        this.metadata = tempMap;
    }
 
    // Method 1
    public String getName() { return name; }
 
    // Method 2
    public int getRegNo() { return regNo; }
   
    // Note that there should not be any setters
 
    // Method 3
    // User -defined type
    // To get meta data
    public Map<String, String> getMetadata()
    {
 
        // Creating Map with HashMap reference
        Map<String, String> tempMap = new HashMap<>();
 
        for (Map.Entry<String, String> entry :
             this.metadata.entrySet()) {
            tempMap.put(entry.getKey(), entry.getValue());
        }
        return tempMap;
    }
}
 
// Class 2
// Main class
class GFG {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Creating Map object with reference to HashMap
        Map<String, String> map = new HashMap<>();
 
        // Adding elements to Map object
        // using put() method
        map.put("1", "first");
        map.put("2", "second");
 
        Student s = new Student("ABC", 101, map);
 
        // Calling the above methods 1,2,3 of class1
        // inside main() method in class2 and
        // executing the print statement over them
        System.out.println(s.getName());
        System.out.println(s.getRegNo());
        System.out.println(s.getMetadata());
 
        // Uncommenting below line causes error
        // s.regNo = 102;
 
        map.put("3", "third");
        // Remains unchanged due to deep copy in constructor
        System.out.println(s.getMetadata());
        s.getMetadata().put("4", "fourth");
        // Remains unchanged due to deep copy in getter
        System.out.println(s.getMetadata());
    }
}
https://www.geeksforgeeks.org/create-immutable-class-java/#:~:text=Immutable%20class%20in%20java%20means,and%20String%20class%20is%20immutable.

115. any other class than string which is immutable .
 wrapper classes are imutable

116. String s = new String("ABC");
s = new String("xyz");
System.out.println(s);

xyz is output

117. what do you know about string constant pool in java
String pool is nothing but a storage area in Java heap where string literals stores. It is also known as String Intern Pool or String Constant Pool. It is just like object allocation. By default, it is empty and privately maintained by the Java String class.
Remember that all the String literals created with the new keyword take place in the Java heap, not in the String pool.
Whenever we create a string the string object occupies some space in the heap memory. Creating a number of strings may increase the cost and memory too which may reduce the performance also.

The JVM performs some steps during the initialization of string literals that increase the performance and decrease the memory load. To decrease the number of String objects created in the JVM the String class keeps a pool of strings.

When we create a string literal, the JVM first check that literal in the String pool. If the literal is already present in the pool, it returns a reference to the pooled instance. If the literal is not present in the pool, a new String object takes place in the String pool.

118. when we create a new String using new keyword. where it is stored. In string constant pool or heap area.
Remember that all the String literals created with the new keyword take place in the Java heap, not in the String pool.


121. what is compile time constant in java. 
A Java variable is a compile-time constant if it's of a primitive type or String, declared final, initialized within its declaration, and with a constant expression.

Strings are a special case on top of the primitive types because they are immutable and live in a String pool. Therefore, all classes running in an application can share String values.

The term compile-time constants include class constants, but also instance and local variables defined using constant expressions:
public final int maximumLoginAttempts = 5;

public static void main(String[] args) {
    PrintWriter printWriter = System.console().writer();
    printWriter.println(ClassConstants.DEFAULT_USERNAME);

    CompileTimeVariables instance = new CompileTimeVariables();
    printWriter.println(instance.maximumLoginAttempts);

    final String username = "baeldung" + "-" + "user";
    printWriter.println(username);
}
122. what is memory leak.
In Java, the memory leak is a situation when the garbage collector does not recognize the unused objects and they remain in the memory indefinitely that reduces the amount of memory allocated to the application. Because the unused objects still being referenced that may lead to OutOfMemoryError. It also affects the reliability of the application. The following figure represents the memory leak.
123. what are wrapper class.

A Wrapper class is a class whose object wraps or contains primitive data types. When we create an object to a wrapper class, it contains a field and in this field, we can store primitive data types. In other words, we can wrap a primitive value into a wrapper class object.

Need of Wrapper Classes

They convert primitive data types into objects. Objects are needed if we wish to modify the arguments passed into a method (because primitive types are passed by value).
The classes in java.util package handles only objects and hence wrapper classes help in this case also.
Data structures in the Collection framework, such as ArrayList and Vector, store only objects (reference types) and not primitive types.
An object is needed to support synchronization in multithreading.

124. what is autoboxing and autounboxing.
Autoboxing: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing. For example – conversion of int to Integer, long to Long, double to Double etc.
Example:


// Java program to demonstrate Autoboxing
  
import java.util.ArrayList;
class Autoboxing
{
    public static void main(String[] args)
    {
        char ch = 'a';
  
        // Autoboxing- primitive to Character object conversion
        Character a = ch;
  
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
  
        // Autoboxing because ArrayList stores only objects
        arrayList.add(25);
  
        // printing the values from object
        System.out.println(arrayList.get(0));
    }
}
125. what is microservices
Microservices - also known as the microservice architecture - is an architectural style that structures an application as a collection of services that are

Highly maintainable and testable
Loosely coupled
Independently deployable
Organized around business capabilities
Owned by a small team
The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.

126. why do we go for micro services. we can create one big services.
Highly maintainable and testable
Loosely coupled
Independently deployable
Organized around business capabilities
Owned by a small team
The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.

127. what is database. what is mysql database
A database is a separate application that stores a collection of data. Each database has one or more distinct APIs for creating, accessing, managing, searching and replicating the data it holds.
Other kinds of data stores can also be used, such as files on the file system or large hash tables in memory but data fetching and writing would not be so fast and easy with those type of systems.
Nowadays, we use relational database management systems (RDBMS) to store and manage huge volume of data. This is called relational database because all the data is stored into different tables and relations are established using primary keys or other keys known as Foreign Keys.
A Relational DataBase Management System (RDBMS) is a software that −
Enables you to implement a database with tables, columns and indexes.
Guarantees the Referential Integrity between rows of various tables.
Updates the indexes automatically.
Interprets an SQL query and combines information from various tables.

MySQL is a fast, easy-to-use RDBMS
 being used for many small and big businesses. MySQL is developed, marketed and supported by MySQL AB, which is a Swedish company. MySQL is becoming so popular because of many good reasons −
MySQL is released under an open-source license. So you have nothing to pay to use it.
MySQL is a very powerful program in its own right. It handles a large subset of the functionality of the most expensive and powerful database packages.
MySQL uses a standard form of the well-known SQL data language.
MySQL works on many operating systems and with many languages including PHP, PERL, C, C++, JAVA, etc.
MySQL works very quickly and works well even with large data sets.
MySQL is very friendly to PHP, the most appreciated language for web development.
MySQL supports large databases, up to 50 million rows or more in a table. The default file size limit for a table is 4GB, but you can increase this (if your operating system can handle it) to a theoretical limit of 8 million terabytes (TB).
MySQL is customizable. The open-source GPL license allows programmers to modify the MySQL software to fit their own specific environments.

AD
128. what clauses you use in SQL
1. GROUP BY
SQL GROUP BY statement is used to arrange identical data into groups. The GROUP BY statement is used with the SQL SELECT statement.
The GROUP BY statement follows the WHERE clause in a SELECT statement and precedes the ORDER BY clause.
The GROUP BY statement is used with aggregation function.
SELECT COMPANY, COUNT(*)  
FROM PRODUCT_MAST   
GROUP BY COMPANY;

 HAVING
HAVING clause is used to specify a search condition for a group or an aggregate.
Having is used in a GROUP BY clause. If you are not using GROUP BY clause then you can use HAVING function like a WHERE clause.
selECT COMPANY, COUNT(*)  
FROM PRODUCT_MAST   
GROUP BY COMPANY  
HAVING COUNT(*)>2;

3. ORDER BY
The ORDER BY clause sorts the result-set in ascending or descending order.
It sorts the records in ascending order by default. DESC keyword is used to sort the records in descending order.
Syntax:SELECT *  
FROM CUSTOMER  
ORDER BY NAME;

129. what is maven why do we use it.
mave is a build tool. maven will download all the depencdency you mention in pom.xml file and builds the project for you.

130. what are design patterns.
https://www.javatpoint.com/design-patterns-in-java
clearly read about it. there are many design patterns. 

131. collections . why do we use collection
Collection: Collection is a interface present in java.util.package. It is used to represent a group of individual objects as a single unit. It is similar to the container in the C++ language. The collection is considered as the root interface of the collection framework. It provides several classes and interfaces to represent a group of individual objects as a single unit. 

The List, Set, and Queue are the main sub-interfaces of the collection interface. The map interface is also part of the java collection framework, but it doesn’t inherit the collection of the interface. The add(), remove(), clear(), size(), and contains() are the important methods of the Collection interface.

Declaration:

public interface Collection<E> extends Iterable<E>

Type Parameters: E - the type of elements returned by this iterator
Collections: Collections is a utility class present in java.util.package. It defines several utility methods like sorting and searching which is used to operate on collection. It has all static methods. These methods provide much-needed convenience to developers, allowing them to effectively work with Collection Framework. For example, It has a method sort() to sort the collection elements according to default sorting order, and it has a method min(), and max() to find the minimum and maximum value respectively in the collection elements.

Declaration:

public class Collections extends Object
Collection vs Collections:                                                           

                                  Collection	                                          Collections
It is an interface.	It is a utility class.
It is used to represent a group of individual objects as a single unit. 	It defines several utility methods that are used to operate on collection.
The Collection is an interface that contains a static method since java8. The Interface can also contain abstract and default methods.	It contains only static methods.

132. collection is a interface or class.
collection is a interface. above question have detailed aswer.
133. do you know collections concept.


135. is array is fiexed size.  yes 


136. does map belongs to collection or not..??
The map interface is present in java.util package represents a mapping between a key and a value. The Map interface is not a subtype of the Collection interface. Therefore it behaves a bit differently from the rest of the collection types. A map contains unique keys.
137. will map implements collection interface
Collections in any language is an interface that stores similar data type objects and provides an iteration functionality. The common extensions of Collection are List and Set.

The Map is a well-known data structure used to store key-value pairs where keys will be unique.
We can take a reference of any language but let's look at the example of Java for reference as Collection Framework from Java is very popular.

Java has Iterable interface which is extended by Collection. The Collection is further extended by List, Queue and Set which has their different-different implementations but the unique thing notice is that the Map interface doesn't extend Collection interface.
Because they are of an incompatible type.
List, Set and Queue are a collection of similar kind of objects but just values where a Map is a collection of key and value pairs.

List Set and Queue have add as a function which takes a value as param to add an element whereas Map has put as a function which takes a key and a value as params to add a key-value pair.

List, Set and Queue provide iterate functionality over the value whereas Maps has keys to iterate over which is ultimately a Set and Values as Collection.
138. can value of a map can be another map..??
 
139. what is covarient return type. 
The covariant return type specifies that the return type may vary in the same direction as the subclass.

Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let's take a simple example:
Simple example of Covariant Return Type
FileName: B1.java

class A{    
A get(){return this;}    
}    
    
class B1 extends A{    
@Override  
B1 get(){return this;}    
void message(){System.out.println("welcome to covariant return type");}    
    
public static void main(String args[]){    
new B1().get().message();    
}    
}    
140.what is SDLC 
SDLC stands for Software Development Life Cycle. SDLC is a process that consists of a series of planned activities to develop or alter the Software Products. This tutorial will give you an overview of the SDLC basics, SDLC models available and their application in the industry. This tutorial also elaborates on other related methodologies like Agile, RAD and Prototyping
141. what is differnce between waterfall and agaile methodlogy.
Waterfall vs Agile Key Difference
Waterfall is a Liner Sequential Life Cycle Model whereas Agile is a continuous iteration of development and testing in the software development process.
In Agile vs Waterfall difference, the Agile methodology is known for its flexibility whereas Waterfall is a structured software development methodology.
Comparing the Waterfall methodology vs Agile which follows an incremental approach whereas the Waterfall is a sequential design process.
Agile performs testing concurrently with software development whereas in Waterfall methodology testing comes after the “Build” phase.
Agile allows changes in project development requirement whereas Waterfall has no scope of changing the requirements once the project development starts.
Advantages of Waterfall Model:
It is one the easiest model to manage. Because of its nature, each phase has specific deliverables and a review process.
It works well for smaller size projects where requirements are easily understandable.
Faster delivery of the project
Process and results are well documented.
Easily adaptable method for shifting teams
This project management methodology is beneficial to manage dependencies.
Advantages of the Agile Model:
It is focused client process. So, it makes sure that the client is continuously involved during every stage.
Agile teams are extremely motivated and self-organized so it likely to provide a better result from the development projects.
Agile software development method assures that quality of the development is maintained
The process is completely based on the incremental progress. Therefore, the client and team know exactly what is complete and what is not. This reduces risk in the development process.
Limitations of Waterfall Model:
It is not an ideal model for a large size project
If the requirement is not clear at the beginning, it is a less effective method.
Very difficult to move back to makes changes in the previous phases.
The testing process starts once development is over. Hence, it has high chances of bugs to be found later in development where they are expensive to fix.
Limitations of Agile Model
It is not useful method for small development projects.
It requires an expert to take important decisions in the meeting.
Cost of implementing an agile method is little more compared to other development methodologies.
The project can easily go off track if the project manager is not clear what outcome he/she wants.
Difference between Agile and Waterfall Model:
Below is a difference between Agile and Waterfall methodologies:

Agile	Waterfall
It separates the project development lifecycle into sprints.	Software development process is divided into distinct phases.
It follows an incremental approach	Waterfall methodology is a sequential design process.
Agile methodology is known for its flexibility.	Waterfall is a structured software development methodology so most times it can be quite rigid.
Agile can be considered as a collection of many different projects.	Software development will be completed as one single project.
Agile is quite a flexible method which allows changes to be made in the project development requirements even if the initial planning has been completed.	There is no scope of changing the requirements once the project development starts.
Agile methodology, follow an iterative development approach because of this planning, development, prototyping and other software development phases may appear more than once.	All the project development phases like designing, development, testing, etc. are completed once in the Waterfall model.
Test plan is reviewed after each sprint	The test plan is rarely discussed during the test phase.
Agile development is a process in which the requirements are expected to change and evolve.	The method is ideal for projects which have definite requirements and changes not at all expected.
In Agile methodology, testing is performed concurrently with software development.	In this methodology, the “Testing” phase comes after the “Build” phase
Agile introduces a product mindset where the software product satisfies needs of its end customers and changes itself as per the customer’s demands.	This model shows a project mindset and places its focus completely on accomplishing the project.
Agile methdology works exceptionally well with Time & Materials or non-fixed funding. It may increase stress in fixed-price scenarios.	Reduces risk in the firm fixed price contracts by getting risk agreement at the beginning of the process.
Prefers small but dedicated teams with a high degree of coordination and synchronization.	Team coordination/synchronization is very limited.
Products owner with team prepares requirements just about every day during a project.	Business analysis prepares requirements before the beginning of the project.
Test team can take part in the requirements change without problems.	It is difficult for the test to initiate any change in requirements.
Description of project details can be altered anytime during the SDLC process.	Detail description needs to implement waterfall software development approach.
The Agile Team members are interchangeable, as a result, they work faster. There is also no need for project managers because the projects are managed by the entire team	In the waterfall method, the process is always straightforward so, project manager plays an essential role during every stage of SDLC.

142. what do you do in aws

143. what is garbage collection in java
Java garbage collection is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program.
144. which collection you used in your project.
hashmap.arraylist.




147. what happens if linked list is full. will linked list have capacity. will arraylist have capacity. 
linked list dont have any capacity. 
ArrayList class is a resizable array, present in java.util package. The difference between an array and an ArrayList in Java, is that the size of an array cannot be modified (i.e. if you want to append/add or remove element(s) to/from an array, you have to create a new array. However, elements can be added/appended or removed from an ArrayList without the need to create a new array.

Whenever an instance of ArrayList in Java is created then by default the capacity of Arraylist is 10. Since ArrayList is a growable array, it automatically resizes itself whenever a number of elements in ArrayList grow beyond a threshold. However, ensureCapacity() method of java.util.ArrayList class can be used to increase the capacity of an ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.


148. what is a marker interface. then what is its use. 
A marker interface is an interface that has no methods or constants inside it. It provides run-time type information about objects, so the compiler and JVM have additional information about the object. A marker interface is also called a tagging interface.
marker interface is used to provide permissions 

if(hashMapDemo instanceof HashMapDemo) {
//    	 thneprovide access
     }


151 differnce between IS-A relationship and Has-A relationship. in java
A relationship in Java means different relations between two or more classes. For example, if a class Bulb inherits another class Device, then we can say that Bulb is having is-a relationship with Device, which implies Bulb is a device.  

In Java, we have two types of relationship:

Is-A relationship: Whenever one class inherits another class, it is called an IS-A relationship.
Has-A relationship: Whenever an instance of one class is used in another class, it is called HAS-A relationship.
152. diffence between comparable and comparator.
Difference between Comparable and Comparator
Comparable and Comparator both are interfaces and can be used to sort collection elements.

However, there are many differences between Comparable and Comparator interfaces that are given below.

Comparable	Comparator
1) Comparable provides a single sorting sequence. In other words, we can sort the collection on the basis of a single element such as id, name, and price.	The Comparator provides multiple sorting sequences. In other words, we can sort the collection on the basis of multiple elements such as id, name, and price etc.
2) Comparable affects the original class, i.e., the actual class is modified.	Comparator doesn't affect the original class, i.e., the actual class is not modified.
3) Comparable provides compareTo() method to sort elements.	Comparator provides compare() method to sort elements.
4) Comparable is present in java.lang package.	A Comparator is present in the java.util package.
5) We can sort the list elements of Comparable type by Collections.sort(List) method.	We can sort the list elements of Comparator type by Collections.sort(List, Comparator) method.
//Java Program to demonstrate the use of Java Comparable.  
//Creating a class which implements Comparable Interface  
import java.util.*;  
import java.io.*;  
class Student implements Comparable<Student>{  
int rollno;  
String name;  
int age;  
Student(int rollno,String name,int age){  
this.rollno=rollno;  
this.name=name;  
this.age=age;  
}  
public int compareTo(Student st){  
if(age==st.age)  
return 0;  
else if(age>st.age)  
return 1;  
else  
return -1;  
}  
}  
//Creating a test class to sort the elements  
public class TestSort3{  
public static void main(String args[]){  
ArrayList<Student> al=new ArrayList<Student>();  
al.add(new Student(101,"Vijay",23));  
al.add(new Student(106,"Ajay",27));  
al.add(new Student(105,"Jai",21));  
  
Collections.sort(al);  
for(Student st:al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
}  
}  
class Student{  
int rollno;  
String name;  
int age;  
Student(int rollno,String name,int age){  
this.rollno=rollno;  
this.name=name;  
this.age=age;  
}  
}  
AgeComparator.java
import java.util.*;  
class AgeComparator implements Comparator<Student>{  
public int compare(Student s1,Student s2){  
if(s1.age==s2.age)  
return 0;  
else if(s1.age>s2.age)  
return 1;  
else  
return -1;  
}  
}  
NameComparator.java
This class provides comparison logic based on the name. In such case, we are using the compareTo() method of String class, which internally provides the comparison logic.

import java.util.*;  
class NameComparator implements Comparator<Student>{  
public int compare(Student s1,Student s2){  
return s1.name.compareTo(s2.name);  
}  
}  
TestComparator.java
In this class, we are printing the values of the object by sorting on the basis of name and age.

//Java Program to demonstrate the use of Java Comparator  
import java.util.*;  
import java.io.*;  
class TestComparator{  
public static void main(String args[]){  
//Creating a list of students  
ArrayList<Student> al=new ArrayList<Student>();  
al.add(new Student(101,"Vijay",23));  
al.add(new Student(106,"Ajay",27));  
al.add(new Student(105,"Jai",21));  
  
System.out.println("Sorting by Name");  
//Using NameComparator to sort the elements  
Collections.sort(al,new NameComparator());  
//Traversing the elements of list  
for(Student st: al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
  
System.out.println("sorting by Age");  
//Using AgeComparator to sort the elements  
Collections.sort(al,new AgeComparator());  
//Travering the list again  
for(Student st: al){  
System.out.println(st.rollno+" "+st.name+" "+st.age);  
}  
  
}  
}  
153. what are the cursors in in sql
A cursor in SQL is a temporary work area created in system memory when a SQL statement is executed. A SQL cursor is a set of rows together with a pointer that identifies a current row. It is a database object to retrieve data from a result set one row at a time. It is useful when we want to manipulate the record of a table in a singleton method, in other words, one row at a time. In other words, a cursor can hold more than one row but can process only one row at a time. The set of rows the cursor holds is called the active set.
 
Types of Cursors in SQL
 
There are the following two types of cursors in SQL:
Implicit Cursor
Explicit Cursor
Implicit Cursor
 
These types of cursors are generated and used by the system during the manipulation of a DML query (INSERT, UPDATE, and DELETE). An implicit cursor is also generated by the system when a single row is selected by a SELECT command.
 
Explicit Cursor
 
This type of cursor is generated by the user using a SELECT command. An explicit cursor contains more than one row, but only one row can be processed at a time. An explicit cursor moves one by one over the records. An explicit cursor uses a pointer that holds the record of a row. After fetching a row, the cursor pointer moves to the next row.
 
Main components of Cursors
 
Each cursor contains the followings 5 parts,
Declare Cursor: In this part, we declare variables and return a set of values.
Open: This is the entering part of the cursor.
Fetch: Used to retrieve the data row by row from a cursor.
Close: This is an exit part of the cursor and used to close a cursor.
Deallocate: In this part, we delete the cursor definition and release all the system resources associated with the cursor.
154. what is concurrent modification excpetion. 
The ConcurrentModificationException occurs when an object is tried to be modified concurrently when it is not permissible. This exception usually comes when one is working with Java Collection classes.

For Example - It is not permissible for a thread to modify a Collection when some other thread is iterating over it. This is because the result of the iteration becomes undefined with it. Some implementation of the Iterator class throws this exception, including all those general-purpose implementations of Iterator which are provided by the JRE. Iterators which do this are called fail-fast as they throw the exception quickly as soon as they encounter such situation rather than facing undetermined behavior of the collection any time in the future.
154. what is the differnce bettwen throw and throws keyword
The throw and throws is the concept of exception handling where the throw keyword throw the exception explicitly from a method or a block of code whereas the throws keyword is used in signature of the method.

155. what happens if we write a method which throws exception inside a try catch block.
exception goes to catch block if there is no catch block then the control goes to the method which called this method.


157.  what makes java functional programming.
Declarative programming, as such, leads to very concise and readable programs. Functional programming, being a subset of declarative programming, offers several constructs like higher-order functions, function composition, and function chaining. Think of the benefits that Stream API has brought into Java 8 for handling data manipulations.

But don't get tempted to switch over unless completely ready. Please note that functional programming is not a simple design pattern that we can immediately use and benefit from. Functional programming is more of a change in how we reason about problems and their solutions and how to structure the algorithm.

158. where do we use this keyword and super key word
this keyword is used to refer any variable of instance. super is used to refer the super class variable.


159. can we use this or super  keyword in static method. 
NO
160.  write a program to reverse a number. 

161. what are the ways of creating thread. which is the best way of creating a trhead
thead can be created by extending thread class are implementing runnable interface

162. how do we start a thread.

163. what happens is sleep in thread. and wait in thread. what happens if we dirctly call .run method and not calling .start method.

164. what is join method.

166. why we use springboot over spring. 
Spring Boot is basically an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring application.

It takes an opinionated view of the Spring platform, which paves the way for a faster and more efficient development ecosystem.

Here are just a few of the features in Spring Boot:

Opinionated ‘starter' dependencies to simplify the build and application configuration
Embedded server to avoid complexity in application deployment
Metrics, Health check, and externalized configuration
Automatic config for Spring functionality – whenever possible
Let's get familiar with both of these frameworks step by step.

167. what are the types of joins in sql
(INNER) JOIN: Returns records that have matching values in both tables
LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table
FULL (OUTER) JOIN: Returns all records when there is a match in either left or right table

168. what is polymorphisum.: taking many forms
 
polymorphisum without inheritance. overloding. 

169. what is data hiding and data binding. 
Encapsulation is a way of binding together the data and the code that operates on the data. It is a mechanism used to hide the data implementation details while exposing the data abstraction to the outside world. The process of hiding information behind a well-defined interface is known as encapsulation.2
170. what is copy constructor.
A copy constructor in a Java class is a constructor that creates an object using another object of the same Java class.

That's helpful when we want to copy a complex object that has several fields, or when we want to make a deep copy of an existing object.
public class Employee {
    private int id;
    private String name;
  
    public Employee(Employee employee) {
    }
}
Then, we copy each field of the input object into the new instance:

public class Employee {
    private int id;
    private String name;
    
    public Employee(Employee employee) {
        this.id = employee.id;
        this.name = employee.name;
    }
}

171. what is exception handling. 
The Exception Handling in Java is one of the powerful mechanism to handle the runtime errors so that the normal flow of the application can be maintained.

In this tutorial, we will learn about Java exceptions, it's types, and the difference between checked and unchecked exceptions.


176. what is scop of a bean
In this quick tutorial, we'll learn about the different types of bean scopes in the Spring framework.

The scope of a bean defines the life cycle and visibility of that bean in the contexts we use it.

The latest version of the Spring framework defines 6 types of scopes:

singleton
prototype
request
session
application
websocket


179. what is a constructor way ofcreating bean
As of Spring 4.3, classes with a single constructor can omit the @Autowired annotation. This is a nice little bit of convenience and boilerplate removal.

On top of that, also starting with 4.3, we can leverage the constructor-based injection in @Configuration annotated classes. In addition, if such a class has only one constructor, we can omit the @Autowired annotation as well.

180. limitations of autowring.
Autowiring is less exact than explicit wiring. Spring is careful to avoid guessing in the case of ambiguity that might have unexpected results, the relationships between Spring-managed objects are no longer document explicitly.
Wiring information may not be available to tools that generate documentation from a Spring container.
Multiple bean definition within the container may match the type specified by the constructor or setter method argument to be autowired.



194. Is string a class or keyword.
class


201. what is restful webservices.
REST stands for REpresentational State Transfer.

REST is an architectural style not a protocol.

Advantages of RESTful Web Services
Fast: RESTful Web Services are fast because there is no strict specification like SOAP. It consumes less bandwidth and resource.

Language and Platform independent: RESTful web services can be written in any programming language and executed in any platform.

Can use SOAP: RESTful web services can use SOAP web services as the implementation.

Permits different data format: RESTful web service permits different data format such as Plain Text, HTML, XML and JSON.
202. what is acutator in springboot.


206. where we put our depencdenices in spring boot. in pom.xml

208. what is functional interface..??
A functional interface is an interface that contains only one abstract method. They can have only one functionality to exhibit. From Java 8 onwards, lambda expressions can be used to represent the instance of a functional interface. A functional interface can have any number of default methods. Runnable, ActionListener, Comparable are some of the examples of functional interfaces. 

Functional Interface is additionally recognized as Single Abstract Method Interfaces. In short, they are also known as SAM interfaces. Functional interfaces in Java are the new feature that provides users with the approach of fundamental programming. 

Functional interfaces are included in Java SE 8 with Lambda expressions and Method references in order to make code more readable, clean, and straightforward. Functional interfaces are interfaces that ensure that they include precisely only one abstract method. Functional interfaces are used and executed by representing the interface with an annotation called @FunctionalInterface. As described earlier, functional interfaces can contain only one abstract method. However, they can include any quantity of default and static methods. 

In Functional interfaces, there is no need to use the abstract keyword as it is optional to use the abstract keyword because, by default, the method defined inside the interface is abstract only. We can also call Lambda expressions as the instance of functional interface.

Before Java 8, we had to create anonymous inner class objects or implement these interfaces.
210. differnce between set and map.
Difference Between Set and Map Interfaces
Both interfaces are used to store the collection of objects as a single unit. The main difference between Set and Map is that Set contains only data elements, and the Map contains the data in the key-value pair, so Map contains key and its value.

Now, let's understand some major differences between both of them.

S.No.	Set                                                	Map 
1.	Set is used to construct the mathematical Set in Java.	Map is used to do mapping in the database.
2.	It cannot contain repeated values.	It can have the same value for different keys.
3.	Set doesn't allow us to add the same elements in it. Each class that implements the Set interface contains only the unique value.	Map contains unique key and repeated values. In Map, one or more keys can have the same values, but two keys cannot be the same.
4.	We can easily iterate the Set elements using the keyset() and the entryset() method of it.	Map elements cannot be iterated. We need to convert Map into Set for iterating the elements.
5.	Insertion order is not maintained by the Set interface. However, some of its classes, like LinkedHashSet, maintains the insertion order.	The insertion order is also not maintained by the Map. However, some of the Map classes like TreeMap and LinkedHashMap does the same.

211. in map duplication will be allowed. 
duplication of values allowed but duplication of keys not allowed.

212. what is generics.
Generics means parameterized types. The idea is to allow type (Integer, String, … etc., and user-defined types) to be a parameter to methods, classes, and interfaces. Using Generics, it is possible to create classes that work with different data types. An entity such as class, interface, or method that operates on a parameterized type is a generic entity.
The Object is the superclass of all other classes, and Object reference can refer to any object. These features lack type safety. Generics add that type of safety feature. We will discuss that type of safety feature in later examples.

Generics in Java are similar to templates in C++. For example, classes like HashSet, ArrayList, HashMap, etc., use generics very well. There are some fundamental differences between the two approaches to generic types. 
Generic Method: Generic Java method takes a parameter and returns some value after performing a task. It is exactly like a normal function, however, a generic method has type parameters that are cited by actual type. This allows the generic method to be used in a more general way. The compiler takes care of the type of safety which enables programmers to code easily since they do not have to perform long, individual type castings.

Generic Classes: A generic class is implemented exactly like a non-generic class. The only difference is that it contains a type parameter section. There can be more than one type of parameter, separated by a comma. The classes, which accept one or more parameters, ​are known as parameterized classes or parameterized types.

Generic Class 
Like C++, we use <> to specify parameter types in generic class creation. To create objects of a generic class, we use the following syntax. 
217. can we have multiple try blocks 
In Java, using a try block inside another try block is permitted. It is called as nested try block. Every statement that we enter a statement in try block, context of that exception is pushed onto the stack.

For example, the inner try block can be used to handle ArrayIndexOutOfBoundsException while the outer try block can handle the ArithemeticException (division by zero).

Why use nested try block
Sometimes a situation may arise where a part of a block may cause one error and the entire block itself may cause another error. In such cases, exception handlers have to be nested.
218. nested try blocks
public class NestedTryBlock{    
 public static void main(String args[]){   
 //outer try block   
  try{    
  //inner try block 1  
    try{    
     System.out.println("going to divide by 0");    
     int b =39/0;    
   }  
    //catch block of inner try block 1  
    catch(ArithmeticException e)  
    {  
      System.out.println(e);  
    }    
       
    
    //inner try block 2  
    try{    
    int a[]=new int[5];    
  
    //assigning the value out of array bounds  
     a[5]=4;    
     }  
  
    //catch block of inner try block 2  
    catch(ArrayIndexOutOfBoundsException e)  
    {  
       System.out.println(e);  
    }    
  
      
    System.out.println("other statement");    
  }  
  //catch block of outer try block  
  catch(Exception e)  
  {  
    System.out.println("handled the exception (outer catch)");  
  }    
    
  System.out.println("normal flow..");    
 }    
}  
219. multiple catch blocks
Before Java 7, we had to catch only one exception type in each catch block. So, whenever we needed to handle more than one specific exception but take some action for all exceptions, we had to have more than one catch block containing the same code.

In the following code, we have to handle two different exceptions but take the same action for both. So we needed to have two different catch blocks as of Java 6.0.

// A Java program to demonstrate that we needed
// multiple catch blocks for multiple exceptions
// prior to Java 7
 
import java.util.Scanner;
public class Test
{
    public static void main(String args[])
    {
        Scanner scn = new Scanner(System.in);
        try
        {
            int n = Integer.parseInt(scn.nextLine());
           
            if (99%n == 0)
                System.out.println(n + " is a factor of 99");
        }
        catch (ArithmeticException ex)
        {
            System.out.println("Arithmetic " + ex);
        }
        catch (NumberFormatException ex)
        {
            System.out.println("Number Format Exception " + ex);
        }
    }
}



222. differce between requestMapping and getmapping
Before Spring 4.3, Spring had only @RequestMapping annotation for mapping all the incoming HTTP request URLs to the corresponding controller methods.

For example, in the given below code, we are using the @RequestMapping annotation to map 3 different HTTP requests to their respective controller methods. Notice that we have specified the HTTP request type (GET, POST etc.) as the annotation attribute method.

Mapping controller methods with @RequestMapping
@RequestMapping(value = "/users", method = RequestMethod.GET)
public Users getUsers() {
}

@RequestMapping(value = "/users", method = RequestMethod.POST)
public User createUser(User user) {
}

@RequestMapping(value = "/users/{id}", method = RequestMethod.GET)
public User getUser(@PathVariable("id") String id) {
}
Spring 4.3 introduced five new and more specific annotations for each HTTP request type.

@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
Using these new annotations, we can rewrite the @RequestMapping example as given below. If you see carefully, we do not have the method attribute anymore in the new annotations.

Mapping controller methods with more specific annotations
@GetMapping(value = "/users")
public Users getUsers() {
}

@PostMapping(value = "/users")
public User createUser(User user) {
}

@GetMapping(value = "/users/{id}")
public User getUser(@PathVariable("id") String id) {
223. sprig profiles in springboot..??
In this tutorial, we'll focus on introducing Profiles in Spring.

Profiles are a core feature of the framework — allowing us to map our beans to different profiles — for example, dev, test, and prod.

We can then activate different profiles in different environments to bootstrap only the beans we need.
Let's start simple and look at how we can make a bean belong to a particular profile. We use the @Profile annotation — we are mapping the bean to that particular profile; the annotation simply takes the names of one (or multiple) profiles.

Consider a basic scenario: We have a bean that should only be active during development but not deployed in production.
We annotate that bean with a dev profile, and it will only be present in the container during development. In production, the dev simply won't be active:

@Component
@Profile("dev")
public class DevDatasourceConfig

225.  pattern and string reverse program

227. how to make a rest call.
private static void getEmployees()
{
    final String uri = "http://localhost:8080/springrestexample/employees.xml";

    RestTemplate restTemplate = new RestTemplate();
    String result = restTemplate.getForObject(uri, String.class);

    System.out.println(result);
}
228. differnce in regular API and microservices.
Microservices Architecture is an architectural style that structures an application as a collection of small autonomous services. modeled around a business domain.

In a Microservice Architecture, each service is self-contained and implements a single business capability. It is a popular way where we build web applications now, for those reasons we outlined above. To recap, an architecture makes it easier and fastest way to build and work on individual parts of an application, and thus the application as a whole.

Application Program Interface (API) is a way through which you can make sure two or more applications communicate with each other to process the client request.
It is incorrect to say that microservices are like web services but more fine-grained.
APIs are not microservices.
Microservices are not implementation of and API.
Difference between Microservice and API :

SR no	MICROSERVICE	API
1	Microservice are components.	APIs are interface.
2	Microservices can be used to expose one more APIs.	APIs is one of the mean to build and expose microservices architecture.
3	Not all Microservice components expose APIs.	API architecture and Microservices architecture is different.
4	Microservices is small size.	API is large is size in complex implementation cases.
5	Microservices take quick to build.	APIs take longer time build than Microservices .
6	Easy and discrete connection of building blocks.	Highly formatted APIs.
229. why do we nneed iterfaces..?? abstact class and interface 

230.  how to cover REST call part using mockito.
 using when. then statements.
231. how to iterate a hashMap. how to iterate Arraylist.
for( String key : HashMapOhjects.keySet()){
Syso(HashMapOhjects.get(key));
   
}
232. first max and second max of an array
take the array to arraylist.
sortit using collections.sort method.
then you can get any max number.



234. if a class extend exception .then it is a checked or uncheked excpetion
Remember the biggest difference between checked and unchecked exceptions is that checked exceptions are forced by the compiler and used to indicate exceptional conditions that are out of the control of the program, while unchecked exceptions are occurred during runtime and are used to indicate programming errors.

if you create a custom exception. you use it for particular scenario so it is a checked excpetion
Custom Exceptions are user-defined exceptions. These are written by programmers specifically for there application use cases. To create a checked custom exception, it must extend Exception or its child classes. Unchecked custom exception extends RuntimeException or its child classes.

237. why we have main method in spring boot . what is auto configutation
using main method spring boot starts the application to run on server. Auto configration configures all the depencdency mentioned in the pom.xml file.

238. what is mean by authentication and authorization in restful API.

239. is it mandatoruy to have abstract methods in abstract class..?-No

240. what is the use of abstract class with out abstract methods in java 
Observation 3: In Java, we can have an abstract class without any abstract method. This allows us to create classes that cannot be instantiated but can only be inherited.
An instance of an abstract class can not be created.
Constructors are allowed.
We can have an abstract class without any abstract method.
There can be a final method in abstract class but any abstract method in class(abstract class) can not be declared as final  or in simper terms final method can not be abstract itself as it will yield an error: “Illegal combination of modifiers: abstract and final”
We are not allowed to create objects for an abstract class.
We can define static methods in an abstract class
We can use the abstract keyword for declaring top-level classes (Outer class) as well as inner classes as abstract
If a class contains at least one abstract method then compulsory should declare a class as abstract 
If the Child class is unable to provide implementation to all abstract methods of the Parent class then we should declare that Child class as abstract so that the next level Child class should provide implementation to the remaining abstract method

241. Java Stream API. 
Introduced in Java 8, the Stream API is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result. Before proceeding further let us discuss out the difference between Collection and Streams in order to understand why this concept was introduced.

A stream is not a data structure instead it takes input from the Collections, Arrays, or I/O channels.
Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.
Before moving ahead in the concept consider an example in which we are having ArrayList of integers, and we suppose we apply a filter to get only even numbers from the object inserted.

242. how will you filter null values from list using streams. 
cars.stream()
        .filter(Objects::nonNull)
		
243. how to convert list to map using maps


245. I want remove duplicate values from Arraylist . how to do it.
add the arraylist objects to hashset.

246. HashSET

247. Springboot vs Spring MVC

248. inbuilt server available in Springboot.
tomact server configurable at port 8080

250. methos avalable in rest api.
get,put,post,delete patch.
251. microservices spring security in project. 

252. how to configurte spring secuity in application.
254.  



 


 


